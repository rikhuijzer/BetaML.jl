<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Utils · BetaML.jl Documentation</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">BetaML.jl Documentation</span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Index</a></li><li><a class="tocitem" href="Perceptron.html">Perceptron</a></li><li><a class="tocitem" href="Trees.html">Trees</a></li><li><a class="tocitem" href="Nn.html">Nn</a></li><li><a class="tocitem" href="Clustering.html">Clustering</a></li><li class="is-active"><a class="tocitem" href="Utils.html">Utils</a><ul class="internal"><li><a class="tocitem" href="#Module-Index"><span>Module Index</span></a></li><li><a class="tocitem" href="#Detailed-API"><span>Detailed API</span></a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><input class="collapse-toggle" id="menuitem-7-1" type="checkbox"/><label class="tocitem" for="menuitem-7-1"><span class="docs-label">Getting started</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="tutorials/Getting started/betaml_tutorial_getting_started.html">-</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-2" type="checkbox"/><label class="tocitem" for="menuitem-7-2"><span class="docs-label">A regression task - sharing bike demand prediction</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="tutorials/A regression task - sharing bike demand prediction/betaml_tutorial_regression_sharingBikes.html">A regression task: the prediction of  bike  sharing demand</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-3" type="checkbox"/><label class="tocitem" for="menuitem-7-3"><span class="docs-label">A classification task when labels are known - determining the plant species giving floreal measures</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="tutorials/A classification task when labels are known - determining the plant species giving floreal measures/tutorial_classification_iris.html">-</a></li></ul></li></ul></li><li><a class="tocitem" href="Examples.html">Examples</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="Utils.html">Utils</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="Utils.html">Utils</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/sylvaticus/BetaML.jl/blob/master/docs/src/Utils.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="The-BetaML.Utils-Module"><a class="docs-heading-anchor" href="#The-BetaML.Utils-Module">The BetaML.Utils Module</a><a id="The-BetaML.Utils-Module-1"></a><a class="docs-heading-anchor-permalink" href="#The-BetaML.Utils-Module" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="BetaML.Utils" href="#BetaML.Utils"><code>BetaML.Utils</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia">Utils module</code></pre><p>Provide shared utility functions for various machine learning algorithms. You don&#39;t usually need to import from this module, as each other module (Nn, Perceptron, Clusters,...) reexport it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/648de38c2aa8d256cca18115ac17b0b419fc9d5d/src/Utils.jl#L14-L19">source</a></section></article><h2 id="Module-Index"><a class="docs-heading-anchor" href="#Module-Index">Module Index</a><a id="Module-Index-1"></a><a class="docs-heading-anchor-permalink" href="#Module-Index" title="Permalink"></a></h2><ul><li><a href="Utils.html#BetaML.Utils.FIXEDSEED"><code>BetaML.Utils.FIXEDSEED</code></a></li><li><a href="Utils.html#BetaML.Utils.accuracy-Union{Tuple{T}, Tuple{Array{Dict{T, Float64}, 1}, Vector{T}}} where T"><code>BetaML.Utils.accuracy</code></a></li><li><a href="Utils.html#BetaML.Utils.accuracy-Union{Tuple{T}, Tuple{Vector{T}, Int64}} where T&lt;:Number"><code>BetaML.Utils.accuracy</code></a></li><li><a href="Utils.html#BetaML.Utils.accuracy-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T"><code>BetaML.Utils.accuracy</code></a></li><li><a href="Utils.html#BetaML.Utils.accuracy-Union{Tuple{T}, Tuple{Dict{T, Float64}, T}} where T"><code>BetaML.Utils.accuracy</code></a></li><li><a href="Utils.html#BetaML.Utils.accuracy-Union{Tuple{T}, Tuple{Matrix{T}, Vector{Int64}}} where T&lt;:Number"><code>BetaML.Utils.accuracy</code></a></li><li><a href="Utils.html#BetaML.Utils.aic-Tuple{Any, Any}"><code>BetaML.Utils.aic</code></a></li><li><a href="Utils.html#BetaML.Utils.autoJacobian-Tuple{Any, Any}"><code>BetaML.Utils.autoJacobian</code></a></li><li><a href="Utils.html#BetaML.Utils.batch-Tuple{Integer, Integer}"><code>BetaML.Utils.batch</code></a></li><li><a href="Utils.html#BetaML.Utils.bic-Tuple{Any, Any, Any}"><code>BetaML.Utils.bic</code></a></li><li><a href="Utils.html#BetaML.Utils.celu-Tuple{Any}"><code>BetaML.Utils.celu</code></a></li><li><a href="Utils.html#BetaML.Utils.classCounts-Tuple{Any}"><code>BetaML.Utils.classCounts</code></a></li><li><a href="Utils.html#BetaML.Utils.colsWithMissing-Tuple{Any}"><code>BetaML.Utils.colsWithMissing</code></a></li><li><a href="Utils.html#BetaML.Utils.cosine_distance-Tuple{Any, Any}"><code>BetaML.Utils.cosine_distance</code></a></li><li><a href="Utils.html#BetaML.Utils.crossEntropy-Tuple{Any, Any}"><code>BetaML.Utils.crossEntropy</code></a></li><li><a href="Utils.html#BetaML.Utils.dcelu-Tuple{Any}"><code>BetaML.Utils.dcelu</code></a></li><li><a href="Utils.html#BetaML.Utils.delu-Tuple{Any}"><code>BetaML.Utils.delu</code></a></li><li><a href="Utils.html#BetaML.Utils.dmish-Tuple{Any}"><code>BetaML.Utils.dmish</code></a></li><li><a href="Utils.html#BetaML.Utils.dplu-Tuple{Any}"><code>BetaML.Utils.dplu</code></a></li><li><a href="Utils.html#BetaML.Utils.drelu-Tuple{Any}"><code>BetaML.Utils.drelu</code></a></li><li><a href="Utils.html#BetaML.Utils.dsigmoid-Tuple{Any}"><code>BetaML.Utils.dsigmoid</code></a></li><li><a href="Utils.html#BetaML.Utils.dsoftmax-Tuple{Any}"><code>BetaML.Utils.dsoftmax</code></a></li><li><a href="Utils.html#BetaML.Utils.dsoftplus-Tuple{Any}"><code>BetaML.Utils.dsoftplus</code></a></li><li><a href="Utils.html#BetaML.Utils.dtanh-Tuple{Any}"><code>BetaML.Utils.dtanh</code></a></li><li><a href="Utils.html#BetaML.Utils.elu-Tuple{Any}"><code>BetaML.Utils.elu</code></a></li><li><a href="Utils.html#BetaML.Utils.entropy-Tuple{Any}"><code>BetaML.Utils.entropy</code></a></li><li><a href="Utils.html#BetaML.Utils.generateParallelRngs-Tuple{Random.AbstractRNG, Integer}"><code>BetaML.Utils.generateParallelRngs</code></a></li><li><a href="Utils.html#BetaML.Utils.getPermutations-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T"><code>BetaML.Utils.getPermutations</code></a></li><li><a href="Utils.html#BetaML.Utils.getScaleFactors-Tuple{Any}"><code>BetaML.Utils.getScaleFactors</code></a></li><li><a href="Utils.html#BetaML.Utils.gini-Tuple{Any}"><code>BetaML.Utils.gini</code></a></li><li><a href="Utils.html#BetaML.Utils.integerDecoder-Union{Tuple{T}, Tuple{Any, AbstractVector{T}}} where T"><code>BetaML.Utils.integerDecoder</code></a></li><li><a href="Utils.html#BetaML.Utils.integerEncoder-Tuple{AbstractVector{T} where T}"><code>BetaML.Utils.integerEncoder</code></a></li><li><a href="Utils.html#BetaML.Utils.issortable-Union{Tuple{AbstractArray{T, N}}, Tuple{N}, Tuple{T}} where {T, N}"><code>BetaML.Utils.issortable</code></a></li><li><a href="Utils.html#BetaML.Utils.l1_distance-Tuple{Any, Any}"><code>BetaML.Utils.l1_distance</code></a></li><li><a href="Utils.html#BetaML.Utils.l2_distance-Tuple{Any, Any}"><code>BetaML.Utils.l2_distance</code></a></li><li><a href="Utils.html#BetaML.Utils.l2²_distance-Tuple{Any, Any}"><code>BetaML.Utils.l2²_distance</code></a></li><li><a href="Utils.html#BetaML.Utils.lse-Tuple{Any}"><code>BetaML.Utils.lse</code></a></li><li><a href="Utils.html#BetaML.Utils.makeMatrix-Tuple{AbstractArray}"><code>BetaML.Utils.makeMatrix</code></a></li><li><a href="Utils.html#BetaML.Utils.meanDicts-Tuple{Any}"><code>BetaML.Utils.meanDicts</code></a></li><li><a href="Utils.html#BetaML.Utils.meanRelError-Tuple{Any, Any}"><code>BetaML.Utils.meanRelError</code></a></li><li><a href="Utils.html#BetaML.Utils.mish-Tuple{Any}"><code>BetaML.Utils.mish</code></a></li><li><a href="Utils.html#BetaML.Utils.mode-Union{Tuple{AbstractArray{Dict{T, Float64}, N} where N}, Tuple{T}} where T"><code>BetaML.Utils.mode</code></a></li><li><a href="Utils.html#BetaML.Utils.oneHotEncoder-Union{Tuple{Union{AbstractVector{T}, T}}, Tuple{T}} where T"><code>BetaML.Utils.oneHotEncoder</code></a></li><li><a href="Utils.html#BetaML.Utils.pca-Tuple{Any}"><code>BetaML.Utils.pca</code></a></li><li><a href="Utils.html#BetaML.Utils.plu-Tuple{Any}"><code>BetaML.Utils.plu</code></a></li><li><a href="Utils.html#BetaML.Utils.polynomialKernel-Tuple{Any, Any}"><code>BetaML.Utils.polynomialKernel</code></a></li><li><a href="Utils.html#BetaML.Utils.radialKernel-Tuple{Any, Any}"><code>BetaML.Utils.radialKernel</code></a></li><li><a href="Utils.html#BetaML.Utils.relu-Tuple{Any}"><code>BetaML.Utils.relu</code></a></li><li><a href="Utils.html#BetaML.Utils.scale"><code>BetaML.Utils.scale</code></a></li><li><a href="Utils.html#BetaML.Utils.sigmoid-Tuple{Any}"><code>BetaML.Utils.sigmoid</code></a></li><li><a href="Utils.html#BetaML.Utils.singleUnique-Union{Tuple{Union{AbstractArray{T, N} where N, T}}, Tuple{T}} where T"><code>BetaML.Utils.singleUnique</code></a></li><li><a href="Utils.html#BetaML.Utils.softmax-Tuple{Any}"><code>BetaML.Utils.softmax</code></a></li><li><a href="Utils.html#BetaML.Utils.softplus-Tuple{Any}"><code>BetaML.Utils.softplus</code></a></li><li><a href="Utils.html#BetaML.Utils.squaredCost-Tuple{Any, Any}"><code>BetaML.Utils.squaredCost</code></a></li><li><a href="Utils.html#BetaML.Utils.sterling-Tuple{BigInt, BigInt}"><code>BetaML.Utils.sterling</code></a></li><li><a href="Utils.html#BetaML.Utils.variance-Tuple{Any}"><code>BetaML.Utils.variance</code></a></li></ul><h2 id="Detailed-API"><a class="docs-heading-anchor" href="#Detailed-API">Detailed API</a><a id="Detailed-API-1"></a><a class="docs-heading-anchor-permalink" href="#Detailed-API" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BetaML.Utils.FIXEDSEED" href="#BetaML.Utils.FIXEDSEED"><code>BetaML.Utils.FIXEDSEED</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">FIXEDSEED</code></pre><p>Fixed seed to allow reproducible results. This is the seed used to obtain the same results under unit tests.</p><p>Use it with:</p><ul><li><code>myAlgorithm(;rng=FIXEDRNG)</code>             # always produce the same sequence of results on each run of the script (&quot;pulling&quot; from the same rng object on different calls)</li><li><code>myAlgorithm(;rng=copy(FIXEDRNG)</code>        # always produce the same result (new rng object on each call)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/648de38c2aa8d256cca18115ac17b0b419fc9d5d/src/Utils.jl#L44-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.error-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T" href="#Base.error-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T"><code>Base.error</code></a> — <span class="docstring-category">Method</span></header><section><div><p>error(ŷ,y;ignoreLabels=false) - Categorical error (T vs T)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/648de38c2aa8d256cca18115ac17b0b419fc9d5d/src/Utils.jl#L669">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.error-Union{Tuple{T}, Tuple{Array{Dict{T, Float64}, 1}, Vector{T}}} where T" href="#Base.error-Union{Tuple{T}, Tuple{Array{Dict{T, Float64}, 1}, Vector{T}}} where T"><code>Base.error</code></a> — <span class="docstring-category">Method</span></header><section><div><p>error(ŷ,y) - Categorical error with with probabilistic predictions of a dataset given in terms of a dictionary of probabilities (Dict{T,Float64} vs T). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/648de38c2aa8d256cca18115ac17b0b419fc9d5d/src/Utils.jl#L756">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.error-Union{Tuple{T}, Tuple{Matrix{T}, Vector{Int64}}} where T&lt;:Number" href="#Base.error-Union{Tuple{T}, Tuple{Matrix{T}, Vector{Int64}}} where T&lt;:Number"><code>Base.error</code></a> — <span class="docstring-category">Method</span></header><section><div><p>error(ŷ,y) - Categorical error with probabilistic predictions of a dataset (PMF vs Int). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/648de38c2aa8d256cca18115ac17b0b419fc9d5d/src/Utils.jl#L754">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.error-Union{Tuple{T}, Tuple{Vector{T}, Int64}} where T&lt;:Number" href="#Base.error-Union{Tuple{T}, Tuple{Vector{T}, Int64}} where T&lt;:Number"><code>Base.error</code></a> — <span class="docstring-category">Method</span></header><section><div><p>error(ŷ,y) - Categorical error with probabilistic prediction of a single datapoint (PMF vs Int). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/648de38c2aa8d256cca18115ac17b0b419fc9d5d/src/Utils.jl#L752">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.reshape-Union{Tuple{T}, Tuple{T, Vararg{Any, N} where N}} where T&lt;:Number" href="#Base.reshape-Union{Tuple{T}, Tuple{T, Vararg{Any, N} where N}} where T&lt;:Number"><code>Base.reshape</code></a> — <span class="docstring-category">Method</span></header><section><div><p>reshape(myNumber, dims..) - Reshape a number as a n dimensional Array </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/648de38c2aa8d256cca18115ac17b0b419fc9d5d/src/Utils.jl#L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Api.partition-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{Float64}}} where T&lt;:AbstractArray" href="#BetaML.Api.partition-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{Float64}}} where T&lt;:AbstractArray"><code>BetaML.Api.partition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">partition(data,parts;shuffle=true)</code></pre><p>Partition (by rows) one or more matrices according to the shares in <code>parts</code>.</p><p><strong>Parameters</strong></p><ul><li><code>data</code>: A matrix/vector or a vector of matrices/vectors</li><li><code>parts</code>: A vector of the required shares (must sum to 1)</li><li><code>shufle</code>: Whether to randomly shuffle the matrices (preserving the relative order between matrices)</li><li><code>rng</code>: Random Number Generator (see <a href="Utils.html#BetaML.Utils.FIXEDSEED"><code>FIXEDSEED</code></a>) [deafult: <code>Random.GLOBAL_RNG</code>]</li></ul><p><strong>Example:</strong></p><p><code>julia julia&gt; x = [1:10 11:20] julia&gt; y = collect(31:40) julia&gt; ((xtrain,xtest),(ytrain,ytest)) = partition([x,y],[0.7,0.3])</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/648de38c2aa8d256cca18115ac17b0b419fc9d5d/src/Utils.jl#L315-L332">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Utils.accuracy-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T" href="#BetaML.Utils.accuracy-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T"><code>BetaML.Utils.accuracy</code></a> — <span class="docstring-category">Method</span></header><section><div><p>accuracy(ŷ,y;ignoreLabels=false) - Categorical accuracy between two vectors (T vs T). If </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/648de38c2aa8d256cca18115ac17b0b419fc9d5d/src/Utils.jl#L645">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Utils.accuracy-Union{Tuple{T}, Tuple{Array{Dict{T, Float64}, 1}, Vector{T}}} where T" href="#BetaML.Utils.accuracy-Union{Tuple{T}, Tuple{Array{Dict{T, Float64}, 1}, Vector{T}}} where T"><code>BetaML.Utils.accuracy</code></a> — <span class="docstring-category">Method</span></header><section><div><p>accuracy(ŷ,y;tol)</p><p>Categorical accuracy with probabilistic predictions of a dataset given in terms of a dictionary of probabilities (Dict{T,Float64} vs T).</p><p><strong>Parameters:</strong></p><ul><li><code>ŷ</code>: A narray where each item is the estimated probability mass function in terms of a Dictionary(Item1 =&gt; Prob1, Item2 =&gt; Prob2, ...)</li><li><code>y</code>: The N array with the correct category for each point <span>$n$</span>.</li><li><code>tol</code>: The tollerance to the prediction, i.e. if considering &quot;correct&quot; only a prediction where the value with highest probability is the true value (<code>tol</code> = 1), or consider instead the set of <code>tol</code> maximum values [def: <code>1</code>].</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/648de38c2aa8d256cca18115ac17b0b419fc9d5d/src/Utils.jl#L734-L744">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Utils.accuracy-Union{Tuple{T}, Tuple{Dict{T, Float64}, T}} where T" href="#BetaML.Utils.accuracy-Union{Tuple{T}, Tuple{Dict{T, Float64}, T}} where T"><code>BetaML.Utils.accuracy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">accuracy(ŷ,y;tol)</code></pre><p>Categorical accuracy with probabilistic prediction of a single datapoint given in terms of a dictionary of probabilities (Dict{T,Float64} vs T).</p><p><strong>Parameters:</strong></p><ul><li><code>ŷ</code>: The returned probability mass function in terms of a Dictionary(Item1 =&gt; Prob1, Item2 =&gt; Prob2, ...)</li><li><code>tol</code>: The tollerance to the prediction, i.e. if considering &quot;correct&quot; only a prediction where the value with highest probability is the true value (<code>tol</code> = 1), or consider instead the set of <code>tol</code> maximum values [def: <code>1</code>].</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/648de38c2aa8d256cca18115ac17b0b419fc9d5d/src/Utils.jl#L688-L696">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Utils.accuracy-Union{Tuple{T}, Tuple{Matrix{T}, Vector{Int64}}} where T&lt;:Number" href="#BetaML.Utils.accuracy-Union{Tuple{T}, Tuple{Matrix{T}, Vector{Int64}}} where T&lt;:Number"><code>BetaML.Utils.accuracy</code></a> — <span class="docstring-category">Method</span></header><section><div><p>accuracy(ŷ,y;tol,ignoreLabels)</p><p>Categorical accuracy with probabilistic predictions of a dataset (PMF vs Int).</p><p><strong>Parameters:</strong></p><ul><li><code>ŷ</code>: An (N,K) matrix of probabilities that each <span>$\hat y_n$</span> record with <span>$n \in 1,....,N$</span>  being of category <span>$k$</span> with <span>$k \in 1,...,K$</span>.</li><li><code>y</code>: The N array with the correct category for each point <span>$n$</span>.</li><li><code>tol</code>: The tollerance to the prediction, i.e. if considering &quot;correct&quot; only a prediction where the value with highest probability is the true value (<code>tol</code> = 1), or consider instead the set of <code>tol</code> maximum values [def: <code>1</code>].</li><li><code>ignoreLabels</code>: Whether to ignore the specific label order in y. Useful for unsupervised learning algorithms where the specific label order don&#39;t make sense [def: false]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/648de38c2aa8d256cca18115ac17b0b419fc9d5d/src/Utils.jl#L708-L719">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Utils.accuracy-Union{Tuple{T}, Tuple{Vector{T}, Int64}} where T&lt;:Number" href="#BetaML.Utils.accuracy-Union{Tuple{T}, Tuple{Vector{T}, Int64}} where T&lt;:Number"><code>BetaML.Utils.accuracy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">accuracy(ŷ,y;tol)</code></pre><p>Categorical accuracy with probabilistic prediction of a single datapoint (PMF vs Int).</p><p>Use the parameter tol [def: <code>1</code>] to determine the tollerance of the prediction, i.e. if considering &quot;correct&quot; only a prediction where the value with highest probability is the true value (<code>tol</code> = 1), or consider instead the set of <code>tol</code> maximum values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/648de38c2aa8d256cca18115ac17b0b419fc9d5d/src/Utils.jl#L673-L678">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Utils.aic-Tuple{Any, Any}" href="#BetaML.Utils.aic-Tuple{Any, Any}"><code>BetaML.Utils.aic</code></a> — <span class="docstring-category">Method</span></header><section><div><p>aic(lL,k) -  Akaike information criterion (lower is better)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/648de38c2aa8d256cca18115ac17b0b419fc9d5d/src/Utils.jl#L870">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Utils.autoJacobian-Tuple{Any, Any}" href="#BetaML.Utils.autoJacobian-Tuple{Any, Any}"><code>BetaML.Utils.autoJacobian</code></a> — <span class="docstring-category">Method</span></header><section><div><p>autoJacobian(f,x;nY)</p><p>Evaluate the Jacobian using AD in the form of a (nY,nX) madrix of first derivatives</p><p><strong>Parameters:</strong></p><ul><li><code>f</code>: The function to compute the Jacobian</li><li><code>x</code>: The input to the function where the jacobian has to be computed</li><li><code>nY</code>: The number of outputs of the function <code>f</code> [def: <code>length(f(x))</code>]</li></ul><p><strong>Return values:</strong></p><ul><li>An <code>Array{Float64,2}</code> of the locally evaluated Jacobian</li></ul><p><strong>Notes:</strong></p><ul><li>The <code>nY</code> parameter is optional. If provided it avoids having to compute <code>f(x)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/648de38c2aa8d256cca18115ac17b0b419fc9d5d/src/Utils.jl#L593-L608">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Utils.batch-Tuple{Integer, Integer}" href="#BetaML.Utils.batch-Tuple{Integer, Integer}"><code>BetaML.Utils.batch</code></a> — <span class="docstring-category">Method</span></header><section><div><p>batch(n,bSize;sequential=false,rng)</p><p>Return a vector of <code>bSize</code> vectors of indeces from <code>1</code> to <code>n</code>. Randomly unless the optional parameter <code>sequential</code> is used.</p><p><strong>Example:</strong></p><p><code>julia julia&gt; Utils.batch(6,2,sequential=true) 3-element Array{Array{Int64,1},1}:  [1, 2]  [3, 4]  [5, 6]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/648de38c2aa8d256cca18115ac17b0b419fc9d5d/src/Utils.jl#L287-L301">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Utils.bic-Tuple{Any, Any, Any}" href="#BetaML.Utils.bic-Tuple{Any, Any, Any}"><code>BetaML.Utils.bic</code></a> — <span class="docstring-category">Method</span></header><section><div><p>bic(lL,k,n) -  Bayesian information criterion (lower is better)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/648de38c2aa8d256cca18115ac17b0b419fc9d5d/src/Utils.jl#L868">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Utils.celu-Tuple{Any}" href="#BetaML.Utils.celu-Tuple{Any}"><code>BetaML.Utils.celu</code></a> — <span class="docstring-category">Method</span></header><section><div><p>celu(x; α=1) </p><p>https://arxiv.org/pdf/1704.07483.pdf</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/648de38c2aa8d256cca18115ac17b0b419fc9d5d/src/Utils.jl#L545-L548">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Utils.classCounts-Tuple{Any}" href="#BetaML.Utils.classCounts-Tuple{Any}"><code>BetaML.Utils.classCounts</code></a> — <span class="docstring-category">Method</span></header><section><div><p>classCounts(x)</p><p>Return a dictionary that counts the number of each unique item (rows) in a dataset.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/648de38c2aa8d256cca18115ac17b0b419fc9d5d/src/Utils.jl#L873-L878">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Utils.colsWithMissing-Tuple{Any}" href="#BetaML.Utils.colsWithMissing-Tuple{Any}"><code>BetaML.Utils.colsWithMissing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">colsWithMissing(x)</code></pre><p>Retuyrn an array with the ids of the columns where there is at least a missing value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/648de38c2aa8d256cca18115ac17b0b419fc9d5d/src/Utils.jl#L510-L514">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Utils.cosine_distance-Tuple{Any, Any}" href="#BetaML.Utils.cosine_distance-Tuple{Any, Any}"><code>BetaML.Utils.cosine_distance</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Cosine distance</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/648de38c2aa8d256cca18115ac17b0b419fc9d5d/src/Utils.jl#L862">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Utils.crossEntropy-Tuple{Any, Any}" href="#BetaML.Utils.crossEntropy-Tuple{Any, Any}"><code>BetaML.Utils.crossEntropy</code></a> — <span class="docstring-category">Method</span></header><section><div><p>crossEntropy(ŷ, y; weight)</p><p>Compute the (weighted) cross-entropy between the predicted and the sampled probability distributions.</p><p>To be used in classification problems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/648de38c2aa8d256cca18115ac17b0b419fc9d5d/src/Utils.jl#L633-L640">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Utils.dcelu-Tuple{Any}" href="#BetaML.Utils.dcelu-Tuple{Any}"><code>BetaML.Utils.dcelu</code></a> — <span class="docstring-category">Method</span></header><section><div><p>dcelu(x; α=1) </p><p>https://arxiv.org/pdf/1704.07483.pdf</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/648de38c2aa8d256cca18115ac17b0b419fc9d5d/src/Utils.jl#L548-L551">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Utils.delu-Tuple{Any}" href="#BetaML.Utils.delu-Tuple{Any}"><code>BetaML.Utils.delu</code></a> — <span class="docstring-category">Method</span></header><section><div><p>delu(x; α=1) with α &gt; 0 </p><p>https://arxiv.org/pdf/1511.07289.pdf</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/648de38c2aa8d256cca18115ac17b0b419fc9d5d/src/Utils.jl#L543-L546">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Utils.dmish-Tuple{Any}" href="#BetaML.Utils.dmish-Tuple{Any}"><code>BetaML.Utils.dmish</code></a> — <span class="docstring-category">Method</span></header><section><div><p>dmish(x) </p><p>https://arxiv.org/pdf/1908.08681v1.pdf</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/648de38c2aa8d256cca18115ac17b0b419fc9d5d/src/Utils.jl#L589-L592">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Utils.dplu-Tuple{Any}" href="#BetaML.Utils.dplu-Tuple{Any}"><code>BetaML.Utils.dplu</code></a> — <span class="docstring-category">Method</span></header><section><div><p>dplu(x;α=0.1,c=1) </p><p>Piecewise Linear Unit derivative </p><p>https://arxiv.org/pdf/1809.09534.pdf</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/648de38c2aa8d256cca18115ac17b0b419fc9d5d/src/Utils.jl#L552-L557">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Utils.drelu-Tuple{Any}" href="#BetaML.Utils.drelu-Tuple{Any}"><code>BetaML.Utils.drelu</code></a> — <span class="docstring-category">Method</span></header><section><div><p>drelu(x) </p><p>Rectified Linear Unit </p><p>https://www.cs.toronto.edu/~hinton/absps/reluICML.pdf</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/648de38c2aa8d256cca18115ac17b0b419fc9d5d/src/Utils.jl#L539-L544">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Utils.dsigmoid-Tuple{Any}" href="#BetaML.Utils.dsigmoid-Tuple{Any}"><code>BetaML.Utils.dsigmoid</code></a> — <span class="docstring-category">Method</span></header><section><div><p>dsigmoid(x)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/648de38c2aa8d256cca18115ac17b0b419fc9d5d/src/Utils.jl#L560">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Utils.dsoftmax-Tuple{Any}" href="#BetaML.Utils.dsoftmax-Tuple{Any}"><code>BetaML.Utils.dsoftmax</code></a> — <span class="docstring-category">Method</span></header><section><div><p>dsoftmax(x; β=1) </p><p>Derivative of the softmax function </p><p>https://eli.thegreenplace.net/2016/the-softmax-function-and-its-derivative/</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/648de38c2aa8d256cca18115ac17b0b419fc9d5d/src/Utils.jl#L564-L569">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Utils.dsoftplus-Tuple{Any}" href="#BetaML.Utils.dsoftplus-Tuple{Any}"><code>BetaML.Utils.dsoftplus</code></a> — <span class="docstring-category">Method</span></header><section><div><p>dsoftplus(x) </p><p>https://en.wikipedia.org/wiki/Rectifier<em>(neural</em>networks)#Softplus</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/648de38c2aa8d256cca18115ac17b0b419fc9d5d/src/Utils.jl#L585-L588">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Utils.dtanh-Tuple{Any}" href="#BetaML.Utils.dtanh-Tuple{Any}"><code>BetaML.Utils.dtanh</code></a> — <span class="docstring-category">Method</span></header><section><div><p>dtanh(x)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/648de38c2aa8d256cca18115ac17b0b419fc9d5d/src/Utils.jl#L556">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Utils.elu-Tuple{Any}" href="#BetaML.Utils.elu-Tuple{Any}"><code>BetaML.Utils.elu</code></a> — <span class="docstring-category">Method</span></header><section><div><p>elu(x; α=1) with α &gt; 0 </p><p>https://arxiv.org/pdf/1511.07289.pdf</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/648de38c2aa8d256cca18115ac17b0b419fc9d5d/src/Utils.jl#L541-L544">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Utils.entropy-Tuple{Any}" href="#BetaML.Utils.entropy-Tuple{Any}"><code>BetaML.Utils.entropy</code></a> — <span class="docstring-category">Method</span></header><section><div><p>entropy(x)</p><p>Calculate the entropy for a list of items (or rows).</p><p>See: https://en.wikipedia.org/wiki/Decision<em>tree</em>learning#Gini_impurity</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/648de38c2aa8d256cca18115ac17b0b419fc9d5d/src/Utils.jl#L832-L838">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Utils.generateParallelRngs-Tuple{Random.AbstractRNG, Integer}" href="#BetaML.Utils.generateParallelRngs-Tuple{Random.AbstractRNG, Integer}"><code>BetaML.Utils.generateParallelRngs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">generateParallelRngs(rng::AbstractRNG, n::Integer;reSeed=false)</code></pre><p>For multi-threaded models, return n independent random number generators (one per thread) to be used in threaded computations.</p><p>Note that each ring is a <em>copy</em> of the original random ring. This means that code that <em>use</em> these RNGs will not change the original RNG state.</p><p>Use it with <code>rngs = generateParallelRngs(rng,Threads.nthreads())</code> to have a separate rng per thread. By default the function doesn&#39;t re-seed the RNG, as you may want to have a loop index based re-seeding strategy rather than a threadid-based one (to guarantee the same result independently of the number of threads). If you prefer, you can instead re-seed the RNG here (using the parameter <code>reSeed=true</code>), such that each thread has a different seed. Be aware however that the stream  of number generated will depend from the number of threads at run time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/648de38c2aa8d256cca18115ac17b0b419fc9d5d/src/Utils.jl#L86-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Utils.getPermutations-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T" href="#BetaML.Utils.getPermutations-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T"><code>BetaML.Utils.getPermutations</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getPermutations(v::AbstractArray{T,1};keepStructure=false)</code></pre><p>Return a vector of either (a) all possible permutations (uncollected) or (b) just those based on the unique values of the vector</p><p>Useful to measure accuracy where you don&#39;t care about the actual name of the labels, like in unsupervised classifications (e.g. clustering)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/648de38c2aa8d256cca18115ac17b0b419fc9d5d/src/Utils.jl#L125-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Utils.getScaleFactors-Tuple{Any}" href="#BetaML.Utils.getScaleFactors-Tuple{Any}"><code>BetaML.Utils.getScaleFactors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getScaleFactors(x;skip)</code></pre><p>Return the scale factors (for each dimensions) in order to scale a matrix X (n,d) such that each dimension has mean 0 and variance 1.</p><p><strong>Parameters</strong></p><ul><li><code>x</code>: the (n × d) dimension matrix to scale on each dimension d</li><li><code>skip</code>: an array of dimension index to skip the scaling [def: <code>[]</code>]</li></ul><p><strong>Return</strong></p><ul><li>A touple whose first elmement is the shift and the second the multiplicative</li></ul><p>term to make the scale.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/648de38c2aa8d256cca18115ac17b0b419fc9d5d/src/Utils.jl#L373-L386">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Utils.gini-Tuple{Any}" href="#BetaML.Utils.gini-Tuple{Any}"><code>BetaML.Utils.gini</code></a> — <span class="docstring-category">Method</span></header><section><div><p>gini(x)</p><p>Calculate the Gini Impurity for a list of items (or rows).</p><p>See: https://en.wikipedia.org/wiki/Decision<em>tree</em>learning#Information_gain</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/648de38c2aa8d256cca18115ac17b0b419fc9d5d/src/Utils.jl#L814-L820">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Utils.integerDecoder-Union{Tuple{T}, Tuple{Any, AbstractVector{T}}} where T" href="#BetaML.Utils.integerDecoder-Union{Tuple{T}, Tuple{Any, AbstractVector{T}}} where T"><code>BetaML.Utils.integerDecoder</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">integerDecoder(x,factors::AbstractVector{T};unique)</code></pre><p>Decode an array of integers to an array of T corresponding to the elements of <code>factors</code></p><p><strong>Parameters:</strong></p><ul><li><code>x</code>: The vector to decode</li><li><code>factors</code>: The vector of elements to use for the encoding</li><li><code>unique</code>: Wether <code>factors</code> is already made of unique elements [def: <code>true</code>]</li></ul><p><strong>Return:</strong></p><ul><li>A vector of length(x) elements corresponding to the (unique) <code>factors</code> elements at the position x</li></ul><p><strong>Example:</strong></p><pre><code class="language-none">julia&gt; integerDecoder([1, 2, 2, 3, 2, 1],[&quot;aa&quot;,&quot;cc&quot;,&quot;bb&quot;]) # out: [&quot;aa&quot;,&quot;cc&quot;,&quot;cc&quot;,&quot;bb&quot;,&quot;cc&quot;,&quot;aa&quot;]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/648de38c2aa8d256cca18115ac17b0b419fc9d5d/src/Utils.jl#L266-L281">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Utils.integerEncoder-Tuple{AbstractVector{T} where T}" href="#BetaML.Utils.integerEncoder-Tuple{AbstractVector{T} where T}"><code>BetaML.Utils.integerEncoder</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">integerEncoder(x;factors=unique(x))</code></pre><p>Encode an array of T to an array of integers using the their position in <code>factor</code> vector (default to the unique vector of the input array)</p><p><strong>Parameters:</strong></p><ul><li><code>x</code>: The vector to encode</li><li><code>factors</code>: The vector of factors whose position is the result of the encoding [def: <code>unique(x)</code>]</li></ul><p><strong>Return:</strong></p><ul><li>A vector of [1,length(x)] integers corresponding to the position of each element in the <code>factors</code> vector`</li></ul><p><strong>Note:</strong></p><ul><li>Attention that while this function creates a ordered (and sortable) set, it is up to the user to be sure that this &quot;property&quot; is not indeed used in his code if the unencoded data is indeed unordered.</li></ul><p><strong>Example:</strong></p><pre><code class="language-none">julia&gt; integerEncoder([&quot;a&quot;,&quot;e&quot;,&quot;b&quot;,&quot;e&quot;],factors=[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;]) # out: [1,5,2,5]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/648de38c2aa8d256cca18115ac17b0b419fc9d5d/src/Utils.jl#L244-L260">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Utils.issortable-Union{Tuple{AbstractArray{T, N}}, Tuple{N}, Tuple{T}} where {T, N}" href="#BetaML.Utils.issortable-Union{Tuple{AbstractArray{T, N}}, Tuple{N}, Tuple{T}} where {T, N}"><code>BetaML.Utils.issortable</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return wheather an array is sortable, i.e. has methos issort defined</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/648de38c2aa8d256cca18115ac17b0b419fc9d5d/src/Utils.jl#L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Utils.l1_distance-Tuple{Any, Any}" href="#BetaML.Utils.l1_distance-Tuple{Any, Any}"><code>BetaML.Utils.l1_distance</code></a> — <span class="docstring-category">Method</span></header><section><div><p>L1 norm distance (aka <em>Manhattan Distance</em>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/648de38c2aa8d256cca18115ac17b0b419fc9d5d/src/Utils.jl#L856">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Utils.l2_distance-Tuple{Any, Any}" href="#BetaML.Utils.l2_distance-Tuple{Any, Any}"><code>BetaML.Utils.l2_distance</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Euclidean (L2) distance</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/648de38c2aa8d256cca18115ac17b0b419fc9d5d/src/Utils.jl#L858">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Utils.l2²_distance-Tuple{Any, Any}" href="#BetaML.Utils.l2²_distance-Tuple{Any, Any}"><code>BetaML.Utils.l2²_distance</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Squared Euclidean (L2) distance</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/648de38c2aa8d256cca18115ac17b0b419fc9d5d/src/Utils.jl#L860">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Utils.lse-Tuple{Any}" href="#BetaML.Utils.lse-Tuple{Any}"><code>BetaML.Utils.lse</code></a> — <span class="docstring-category">Method</span></header><section><div><p>LogSumExp for efficiently computing log(sum(exp.(x))) </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/648de38c2aa8d256cca18115ac17b0b419fc9d5d/src/Utils.jl#L970">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Utils.makeMatrix-Tuple{AbstractArray}" href="#BetaML.Utils.makeMatrix-Tuple{AbstractArray}"><code>BetaML.Utils.makeMatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Transform an Array{T,1} in an Array{T,2} and leave unchanged Array{T,2}.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/648de38c2aa8d256cca18115ac17b0b419fc9d5d/src/Utils.jl#L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Utils.meanDicts-Tuple{Any}" href="#BetaML.Utils.meanDicts-Tuple{Any}"><code>BetaML.Utils.meanDicts</code></a> — <span class="docstring-category">Method</span></header><section><div><p>meanDicts(dicts)</p><p>Compute the mean of the values of an array of dictionaries.</p><p>Given <code>dicts</code> an array of dictionaries, <code>meanDicts</code> first compute the union of the keys and then average the values. If the original valueas are probabilities (non-negative items summing to 1), the result is also a probability distribution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/648de38c2aa8d256cca18115ac17b0b419fc9d5d/src/Utils.jl#L914-L922">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Utils.meanRelError-Tuple{Any, Any}" href="#BetaML.Utils.meanRelError-Tuple{Any, Any}"><code>BetaML.Utils.meanRelError</code></a> — <span class="docstring-category">Method</span></header><section><div><p>meanRelError(ŷ,y;normDim=true,normRec=true,p=1)</p><p>Compute the mean relative error (l-1 based by default) between ŷ and y.</p><p>There are many ways to compute a mean relative error. In particular, if normRec (normDim) is set to true, the records (dimensions) are normalised, in the sense that it doesn&#39;t matter if a record (dimension) is bigger or smaller than the others, the relative error is first computed for each record (dimension) and then it is averaged. With both <code>normDim</code> and <code>normRec</code> set to <code>false</code> the function returns the relative mean error; with both set to <code>true</code> (default) it returns the mean relative error (i.e. with p=1 the &quot;<a href="https://en.wikipedia.org/wiki/Mean_absolute_percentage_error">mean absolute percentage error (MAPE)</a>&quot;) The parameter <code>p</code> [def: <code>1</code>] controls the p-norm used to define the error.</p><p>The <em>mean relative error</em> enfatises the relativeness of the error, i.e. all observations and dimensions weigth the same, wether large or small. Conversly, in the <em>relative mean error</em> the same relative error on larger observations (or dimensions) weights more.</p><p>For example, given <code>y = [1,44,3]</code> and <code>ŷ = [2,45,2]</code>, the <em>mean relative error</em> <code>meanRelError(ŷ,y)</code> is <code>0.452</code>, while the <em>relative mean error</em> <code>meanRelError(ŷ,y, normRec=false)</code> is &quot;only&quot; <code>0.0625</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/648de38c2aa8d256cca18115ac17b0b419fc9d5d/src/Utils.jl#L775-L788">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Utils.mish-Tuple{Any}" href="#BetaML.Utils.mish-Tuple{Any}"><code>BetaML.Utils.mish</code></a> — <span class="docstring-category">Method</span></header><section><div><p>mish(x) </p><p>https://arxiv.org/pdf/1908.08681v1.pdf</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/648de38c2aa8d256cca18115ac17b0b419fc9d5d/src/Utils.jl#L587-L590">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Utils.mode-Union{Tuple{AbstractArray{Dict{T, Float64}, N} where N}, Tuple{T}} where T" href="#BetaML.Utils.mode-Union{Tuple{AbstractArray{Dict{T, Float64}, N} where N}, Tuple{T}} where T"><code>BetaML.Utils.mode</code></a> — <span class="docstring-category">Method</span></header><section><div><p>mode(dicts)</p><p>Given a vector of dictionaries representing probabilities it returns the mode of each element in terms of the key</p><p>Use it to return a unique value from a multiclass classifier returning probabilities.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/648de38c2aa8d256cca18115ac17b0b419fc9d5d/src/Utils.jl#L902-L909">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Utils.oneHotEncoder-Union{Tuple{Union{AbstractVector{T}, T}}, Tuple{T}} where T" href="#BetaML.Utils.oneHotEncoder-Union{Tuple{Union{AbstractVector{T}, T}}, Tuple{T}} where T"><code>BetaML.Utils.oneHotEncoder</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">oneHotEncoder(x;d,factors,count)</code></pre><p>Encode arrays (or arrays of arrays) of categorical data as matrices of one column per factor.</p><p>The case of arrays of arrays is for when at each record you have more than one categorical output. You can then decide to encode just the presence of the factors or their counting</p><p><strong>Parameters:</strong></p><ul><li><code>x</code>: The data to convert (array or array of arrays)</li><li><code>d</code>: The number of dimensions in the output matrix [def: <code>maximum(x)</code> for integers and <code>length(factors)</code> otherwise]</li><li><code>factors</code>: The factors from which to encode [def: <code>1:d</code> for integer x or <code>unique(x)</code> otherwise]</li><li><code>count</code>: Wether to count multiple instances on the same dimension/record (<code>true</code>) or indicate just presence. [def: <code>false</code>]</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; oneHotEncoder([&quot;a&quot;,&quot;c&quot;,&quot;c&quot;],factors=[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;])
3×4 Matrix{Int64}:
 1  0  0  0
 0  0  1  0
 0  0  1  0
julia&gt; oneHotEncoder([2,4,4])
3×4 Matrix{Int64}:
 0  1  0  0
 0  0  0  1
 0  0  0  1
 julia&gt; oneHotEncoder([[2,2,1],[2,4,4]],count=true)
2×4 Matrix{Int64}:
 1  2  0  0
 0  1  0  2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/648de38c2aa8d256cca18115ac17b0b419fc9d5d/src/Utils.jl#L180-L210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Utils.pca-Tuple{Any}" href="#BetaML.Utils.pca-Tuple{Any}"><code>BetaML.Utils.pca</code></a> — <span class="docstring-category">Method</span></header><section><div><p>pca(X;K,error)</p><p>Perform Principal Component Analysis returning the matrix reprojected among the dimensions of maximum variance.</p><p><strong>Parameters:</strong></p><ul><li><code>X</code> : The (N,D) data to reproject</li><li><code>K</code> : The number of dimensions to maintain (with K&lt;=D) [def: <code>nothing</code>]</li><li><code>error</code>: The maximum approximation error that we are willing to accept [def: <code>0.05</code>]</li></ul><p><strong>Return:</strong></p><ul><li>A named tuple with:<ul><li><code>X</code>: The reprojected (NxK) matrix with the column dimensions organized in descending order of of the proportion of explained variance</li><li><code>K</code>: The number of dimensions retieved</li><li><code>error</code>: The actual proportion of variance not explained in the reprojected dimensions</li><li><code>P</code>: The (D,K) matrix of the eigenvectors associated to the K-largest eigenvalues used to reproject the data matrix</li><li><code>explVarByDim</code>: An array of dimensions D with the share of the cumulative variance explained by dimensions (the last element being always 1.0)</li></ul></li></ul><p><strong>Notes:</strong></p><ul><li>If <code>K</code> is provided, the parameter <code>error</code> has no effect.</li><li>If one doesn&#39;t know <em>a priori</em> the error that she/he is willling to accept, nor the wished number of dimensions, he/she can run this pca function with <code>out = pca(X,K=size(X,2))</code> (i.e. with K=D), analise the proportions of explained cumulative variance by dimensions in <code>out.explVarByDim</code>, choose the number of dimensions K according to his/her needs and finally pick from the reprojected matrix only the number of dimensions needed, i.e. <code>out.X[:,1:K]</code>.</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia">julia&gt; X = [1 10 100; 1.1 15 120; 0.95 23 90; 0.99 17 120; 1.05 8 90; 1.1 12 95]
6×3 Array{Float64,2}:
 1.0   10.0  100.0
 1.1   15.0  120.0
 0.95  23.0   90.0
 0.99  17.0  120.0
 1.05   8.0   90.0
 1.1   12.0   95.0
 julia&gt; X = pca(X,error=0.05).X
6×2 Array{Float64,2}:
  3.1783   100.449
  6.80764  120.743
 16.8275    91.3551
  8.80372  120.878
  1.86179   90.3363
  5.51254   95.5965</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/648de38c2aa8d256cca18115ac17b0b419fc9d5d/src/Utils.jl#L434-L476">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Utils.plu-Tuple{Any}" href="#BetaML.Utils.plu-Tuple{Any}"><code>BetaML.Utils.plu</code></a> — <span class="docstring-category">Method</span></header><section><div><p>plu(x;α=0.1,c=1) </p><p>Piecewise Linear Unit </p><p>https://arxiv.org/pdf/1809.09534.pdf</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/648de38c2aa8d256cca18115ac17b0b419fc9d5d/src/Utils.jl#L550-L555">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Utils.polynomialKernel-Tuple{Any, Any}" href="#BetaML.Utils.polynomialKernel-Tuple{Any, Any}"><code>BetaML.Utils.polynomialKernel</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Polynomial kernel parametrised with <code>c=0</code> and <code>d=2</code> (i.e. a quadratic kernel). For other <code>cᵢ</code> and <code>dᵢ</code> use <code>K = (x,y) -&gt; polynomialKernel(x,y,c=cᵢ,d=dᵢ)</code> as kernel function in the supporting algorithms</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/648de38c2aa8d256cca18115ac17b0b419fc9d5d/src/Utils.jl#L949-L952">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Utils.radialKernel-Tuple{Any, Any}" href="#BetaML.Utils.radialKernel-Tuple{Any, Any}"><code>BetaML.Utils.radialKernel</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Radial Kernel (aka <em>RBF kernel</em>) parametrised with γ=1/2. For other gammas γᵢ use <code>K = (x,y) -&gt; radialKernel(x,y,γ=γᵢ)</code> as kernel function in the supporting algorithms</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/648de38c2aa8d256cca18115ac17b0b419fc9d5d/src/Utils.jl#L946-L948">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Utils.relu-Tuple{Any}" href="#BetaML.Utils.relu-Tuple{Any}"><code>BetaML.Utils.relu</code></a> — <span class="docstring-category">Method</span></header><section><div><p>relu(x) </p><p>Rectified Linear Unit </p><p>https://www.cs.toronto.edu/~hinton/absps/reluICML.pdf</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/648de38c2aa8d256cca18115ac17b0b419fc9d5d/src/Utils.jl#L537-L542">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Utils.scale" href="#BetaML.Utils.scale"><code>BetaML.Utils.scale</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">scale(x,scaleFactors;rev)</code></pre><p>Perform a linear scaling of x using scaling factors <code>scaleFactors</code>.</p><p><strong>Parameters</strong></p><ul><li><code>x</code>: The (n × d) dimension matrix to scale on each dimension d</li><li><code>scalingFactors</code>: A tuple of the constant and multiplicative scaling factor</li></ul><p>respectively [def: the scaling factors needed to scale x to mean 0 and variance 1]</p><ul><li><code>rev</code>: Whether to invert the scaling [def: <code>false</code>]</li></ul><p><strong>Return</strong></p><ul><li>The scaled matrix</li></ul><p><strong>Notes:</strong></p><ul><li>Also available <code>scale!(x,scaleFactors)</code> for in-place scaling.</li><li>Retrieve the scale factors with the <code>getScaleFactors()</code> function</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/648de38c2aa8d256cca18115ac17b0b419fc9d5d/src/Utils.jl#L399-L416">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Utils.sigmoid-Tuple{Any}" href="#BetaML.Utils.sigmoid-Tuple{Any}"><code>BetaML.Utils.sigmoid</code></a> — <span class="docstring-category">Method</span></header><section><div><p>sigmoid(x)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/648de38c2aa8d256cca18115ac17b0b419fc9d5d/src/Utils.jl#L558">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Utils.singleUnique-Union{Tuple{Union{AbstractArray{T, N} where N, T}}, Tuple{T}} where T" href="#BetaML.Utils.singleUnique-Union{Tuple{Union{AbstractArray{T, N} where N, T}}, Tuple{T}} where T"><code>BetaML.Utils.singleUnique</code></a> — <span class="docstring-category">Method</span></header><section><div><p>singleUnique(x) Return the unique values of x whether x is an array of arrays, an array or a scalar</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/648de38c2aa8d256cca18115ac17b0b419fc9d5d/src/Utils.jl#L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Utils.softmax-Tuple{Any}" href="#BetaML.Utils.softmax-Tuple{Any}"><code>BetaML.Utils.softmax</code></a> — <span class="docstring-category">Method</span></header><section><div><p>softmax (x; β=1) </p><p>The input x is a vector. Return a PMF</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/648de38c2aa8d256cca18115ac17b0b419fc9d5d/src/Utils.jl#L562-L565">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Utils.softplus-Tuple{Any}" href="#BetaML.Utils.softplus-Tuple{Any}"><code>BetaML.Utils.softplus</code></a> — <span class="docstring-category">Method</span></header><section><div><p>softplus(x) </p><p>https://en.wikipedia.org/wiki/Rectifier<em>(neural</em>networks)#Softplus</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/648de38c2aa8d256cca18115ac17b0b419fc9d5d/src/Utils.jl#L583-L586">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Utils.squaredCost-Tuple{Any, Any}" href="#BetaML.Utils.squaredCost-Tuple{Any, Any}"><code>BetaML.Utils.squaredCost</code></a> — <span class="docstring-category">Method</span></header><section><div><p>squaredCost(ŷ,y)</p><p>Compute the squared costs between a vector of prediction and one of observations as (1/2)*norm(y - ŷ)^2.</p><p>Aside the 1/2 term, it correspond to the squared l-2 norm distance and when it is averaged on multiple datapoints corresponds to the Mean Squared Error (<a href="https://en.wikipedia.org/wiki/Mean_squared_error">MSE</a>). It is mostly used for regression problems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/648de38c2aa8d256cca18115ac17b0b419fc9d5d/src/Utils.jl#L764-L771">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Utils.sterling-Tuple{BigInt, BigInt}" href="#BetaML.Utils.sterling-Tuple{BigInt, BigInt}"><code>BetaML.Utils.sterling</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Sterling number: number of partitions of a set of n elements in k sets </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/648de38c2aa8d256cca18115ac17b0b419fc9d5d/src/Utils.jl#L972">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Utils.variance-Tuple{Any}" href="#BetaML.Utils.variance-Tuple{Any}"><code>BetaML.Utils.variance</code></a> — <span class="docstring-category">Method</span></header><section><div><p>variance(x) - population variance</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/648de38c2aa8d256cca18115ac17b0b419fc9d5d/src/Utils.jl#L850">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="Clustering.html">« Clustering</a><a class="docs-footer-nextpage" href="tutorials/Getting started/betaml_tutorial_getting_started.html">- »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 26 March 2021 10:49">Friday 26 March 2021</span>. Using Julia version 1.6.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
