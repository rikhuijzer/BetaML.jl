<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>A classification task when labels are known - determining the country of origin of cars given the cars characteristics · BetaML.jl Documentation</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">BetaML.jl Documentation</span></div><form class="docs-search" action="../../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../index.html">Index</a></li><li><span class="tocitem">Tutorial</span><ul><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox"/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">Getting started</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../Getting started/betaml_tutorial_getting_started.html">Getting started</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Regression - bike sharing</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../Regression - bike sharing/betaml_tutorial_regression_sharingBikes.html">A regression task: the prediction of  bike  sharing demand</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox" checked/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Classification - cars</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href="betaml_tutorial_classification_cars.html">A classification task when labels are known - determining the country of origin of cars given the cars characteristics</a><ul class="internal"><li><a class="tocitem" href="#Library-and-data-loading"><span>Library and data loading</span></a></li><li><a class="tocitem" href="#Random-Forests"><span>Random Forests</span></a></li><li><a class="tocitem" href="#Summary"><span>Summary</span></a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Clusterisation - Iris</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../Clusterisation - Iris/betaml_tutorial_cluster_iris.html">A classification task: the prediction of  plant species from floreal measures (the iris dataset)</a></li></ul></li></ul></li><li><span class="tocitem">API (Reference manual)</span><ul><li><a class="tocitem" href="../../Perceptron.html">Perceptron</a></li><li><a class="tocitem" href="../../Trees.html">Trees</a></li><li><a class="tocitem" href="../../Nn.html">Nn</a></li><li><a class="tocitem" href="../../Clustering.html">Clustering</a></li><li><a class="tocitem" href="../../Utils.html">Utils</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorial</a></li><li><a class="is-disabled">Classification - cars</a></li><li class="is-active"><a href="betaml_tutorial_classification_cars.html">A classification task when labels are known - determining the country of origin of cars given the cars characteristics</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="betaml_tutorial_classification_cars.html">A classification task when labels are known - determining the country of origin of cars given the cars characteristics</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/sylvaticus/BetaML.jl/blob/master/docs/src/tutorials/Classification - cars/betaml_tutorial_classification_cars.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="classification_tutorial"><a class="docs-heading-anchor" href="#classification_tutorial">A classification task when labels are known - determining the country of origin of cars given the cars characteristics</a><a id="classification_tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#classification_tutorial" title="Permalink"></a></h1><p>In this exercise we have some car technical characteristics (mpg, horsepower,weight, model year...) and the country of origin and we would like to create a model such that the country of origin can be accurately predicted given the technical characteristics. As the information to predict is a multi-class one, this is a <em>[classification]</em>(https://en.wikipedia.org/wiki/Statistical_classification) task. It is a challenging exercise due to the simultaneous presence of three factors: (1) presence of missing data; (2) unbalanced data - 254 out of 406 cars are US made; (3) small dataset.</p><p>Data origin:</p><ul><li>dataset description: <a href="https://archive.ics.uci.edu/ml/datasets/auto+mpg">https://archive.ics.uci.edu/ml/datasets/auto+mpg</a></li><li>data source we use here: <a href="https://archive.ics.uci.edu/ml/machine-learning-databases/auto-mpg/auto-mpg.data-original">https://archive.ics.uci.edu/ml/machine-learning-databases/auto-mpg/auto-mpg.data</a></li></ul><p>Field description:</p><ol><li>mpg:           <em>continuous</em></li><li>cylinders:     <em>multi-valued discrete</em></li><li>displacement:  <em>continuous</em></li><li>horsepower:    <em>continuous</em></li><li>weight:        <em>continuous</em></li><li>acceleration:  <em>continuous</em></li><li>model year:    <em>multi-valued discrete</em></li><li>origin:        <em>multi-valued discrete</em></li><li>car name:      <em>string (unique for each instance)</em> - not used here</li></ol><h2 id="Library-and-data-loading"><a class="docs-heading-anchor" href="#Library-and-data-loading">Library and data loading</a><a id="Library-and-data-loading-1"></a><a class="docs-heading-anchor-permalink" href="#Library-and-data-loading" title="Permalink"></a></h2><p>We load a buch of packages that we&#39;ll use during this tutorial..</p><pre><code class="language-julia">using Random, HTTP, CSV, DataFrames, BenchmarkTools, BetaML
import DecisionTree, Flux
import Pipe: @pipe</code></pre><p>To load the data from the internet our workflow is (1) Retrieve the data –&gt; (2) Clean it –&gt; (3) Load it –&gt; (4) Output it as a DataFrame.</p><p>For step (1) we use <code>HTTP.get()</code><code>, for step (2) we use</code>replace!<code>, for steps (3) and (4) we uses the</code>CSV<code>package, and we use the &quot;pip&quot;</code>|&gt;` operator to chain these operations:</p><pre><code class="language-julia">urlDataOriginal = &quot;https://archive.ics.uci.edu/ml/machine-learning-databases/auto-mpg/auto-mpg.data-original&quot;
data = @pipe HTTP.get(urlDataOriginal).body                                                |&gt;
             replace!(_, UInt8(&#39;\t&#39;) =&gt; UInt8(&#39; &#39;))                                        |&gt;
             CSV.File(_, delim=&#39; &#39;, missingstring=&quot;NA&quot;, ignorerepeated=true, header=false) |&gt;
             DataFrame;</code></pre><p>This results in a table where the rows are the observations (the various cars) and the column the fields. All BetaML models expect this layout. As the dataset is ordered, we randomly shuffle the data. Note that we pass to shuffle <code>copy(FIXEDRNG)</code> as the random nuber generator in order to obtain reproducible output ( <a href="../../Utils.html#BetaML.Utils.FIXEDRNG"><code>FIXEDRNG</code></a> is nothing else than an istance of <code>StableRNG(123)</code> defined in the <a href="../../Utils.html#BetaML.Utils"><code>BetaML.Utils</code></a> sub-module, but you can choose of course your own &quot;fixed&quot; RNG). See the <a href="../Getting started/betaml_tutorial_getting_started.html#dealing_with_stochasticity">Dealing with stochasticity</a> section in the <a href="tutorials/Classification - cars/@ref">Getting started</a> tutorial for details.</p><pre><code class="language-julia">data[shuffle(copy(FIXEDRNG),axes(data, 1)), :]
describe(data)</code></pre><table class="data-frame"><thead><tr><th></th><th>variable</th><th>mean</th><th>min</th><th>median</th><th>max</th><th>nmissing</th><th>eltype</th></tr><tr><th></th><th>Symbol</th><th>Union…</th><th>Any</th><th>Union…</th><th>Any</th><th>Int64</th><th>Type</th></tr></thead><tbody><p>9 rows × 7 columns</p><tr><th>1</th><td>Column1</td><td>23.5146</td><td>9.0</td><td>23.0</td><td>46.6</td><td>8</td><td>Union{Missing, Float64}</td></tr><tr><th>2</th><td>Column2</td><td>5.47537</td><td>3.0</td><td>4.0</td><td>8.0</td><td>0</td><td>Float64</td></tr><tr><th>3</th><td>Column3</td><td>194.78</td><td>68.0</td><td>151.0</td><td>455.0</td><td>0</td><td>Float64</td></tr><tr><th>4</th><td>Column4</td><td>105.082</td><td>46.0</td><td>95.0</td><td>230.0</td><td>6</td><td>Union{Missing, Float64}</td></tr><tr><th>5</th><td>Column5</td><td>2979.41</td><td>1613.0</td><td>2822.5</td><td>5140.0</td><td>0</td><td>Float64</td></tr><tr><th>6</th><td>Column6</td><td>15.5197</td><td>8.0</td><td>15.5</td><td>24.8</td><td>0</td><td>Float64</td></tr><tr><th>7</th><td>Column7</td><td>75.9212</td><td>70.0</td><td>76.0</td><td>82.0</td><td>0</td><td>Float64</td></tr><tr><th>8</th><td>Column8</td><td>1.56897</td><td>1.0</td><td>1.0</td><td>3.0</td><td>0</td><td>Float64</td></tr><tr><th>9</th><td>Column9</td><td></td><td>amc ambassador brougham</td><td></td><td>vw rabbit custom</td><td>0</td><td>String</td></tr></tbody></table><p>Columns 1 to 7 contain  characteristics of the car, while column 8 encodes the country or origin (&quot;1&quot; -&gt; US, &quot;2&quot; -&gt; EU, &quot;3&quot; -&gt; Japan). That&#39;s what we want to be able to predict. Columns 9 contains the car name, but we are not going to use this information in this tutorial. Note also that some fields have missing data. Our first step is hence to divide the dataset in features (the x) and the labels (the y) we want to predict. The <code>x</code> is then a Julia standard <code>Matrix</code> of 406 rows by 7 columns and the <code>y</code> is a vector of the 406 observations:</p><pre><code class="language-julia">x     = Matrix{Union{Missing,Float64}}(data[:,1:7]);
y     = Vector{Int64}(data[:,8]);</code></pre><p>Some algorithms that we will use today don&#39;t like missing data, so we need to <em>impute</em> them. Foir this we are using the <a href="../../Clustering.html#BetaML.Clustering.predictMissing"><code>predictMissing</code></a> function provided by the <a href="../../Clustering.html#BetaML.Clustering"><code>BetaML.Clustering</code></a> sub-module. Internally the function uses a Gaussian Mixture Model to assign to the missing walue of a given record an average of the values of the non-missing records weighted for how close they are to our specific record.</p><pre><code class="language-julia">xFull = predictMissing(x,rng=copy(FIXEDRNG)).X̂;</code></pre><pre class="documenter-example-output">Iter. 1:	Var. of the post  20.10554158364678 	  Log-likelihood -12110.417616527317</pre><p>Further, some models don&#39;t work with categorical data as such, so we need to represent our <code>y</code> as a matrix with a separate column for each possible categorical value (the so called &quot;one-hot&quot; representation). For example, within a three classes field, the individual value <code>2</code> (or <code>&quot;Europe&quot;</code> for what it matters) would be represented as the vector <code>[0 1 0]</code>, while <code>3</code> (or <code>&quot;Japan&quot;</code>) wpuld become the vector <code>[0 0 1]</code>. To encode as one-hot we use the function <a href="../../Utils.html#BetaML.Utils.oneHotEncoder-Union{Tuple{Union{AbstractVector{T}, T}}, Tuple{T}} where T"><code>oneHotEncoder</code></a> in <a href="../../Utils.html#BetaML.Utils"><code>BetaML.Utils</code></a></p><pre><code class="language-julia">y_oh  = oneHotEncoder(y);</code></pre><p>In supervised machine learning it is good practice to partition the available data in a <em>training</em>, <em>validation</em>, and <em>test</em> subsets, where the first one is used to train the ML algorithm, the second one to train any eventual &quot;hyper-parameters&quot; of the algorithm and the <em>test</em> subset is finally used to evaluate the quality of the algorithm. Here, for brevity, we use only the <em>train</em> and the <em>test</em> subsets, implicitly assuming we already know the best hyper-parameters. Please refer to the <a href="../Regression - bike sharing/betaml_tutorial_regression_sharingBikes.html#regression_tutorial">regression tutorial</a> for examples of how to use the validation subset to train the hyper-parameters. We use then the <code>partition</code> function in <a href="tutorials/Classification - cars/@ref">BetaML.Utils</a>, where we can specify the different data to partition (that must have the same number of observations) and the shares of observation that we want in each subset.</p><pre><code class="language-julia">((xtrain,xtest),(xtrainFull,xtestFull),(ytrain,ytest),(ytrain_oh,ytest_oh)) = partition([x,xFull,y,y_oh],[0.8,1-0.8],rng=copy(FIXEDRNG));</code></pre><h2 id="Random-Forests"><a class="docs-heading-anchor" href="#Random-Forests">Random Forests</a><a id="Random-Forests-1"></a><a class="docs-heading-anchor-permalink" href="#Random-Forests" title="Permalink"></a></h2><p>We are now ready to use our first model, the Random Forests (in the <a href="../../Trees.html#BetaML.Trees"><code>BetaML.Trees</code></a> sub-module). Random Forests build a &quot;forest&quot; of decision trees models and then average their predictions to make an overall prediction out of a feature vector. To &quot;build&quot; the forest model (i.e. to &quot;train&quot; it) we need to give the model the training feature matrix and the associated &quot;true&quot; training labels, and we need to specify the number of trees to employ (this is an example of hyper-parameters). Here we use 30 individual decision trees. As the labels are encoded using integers,  we need also to use the parameter <code>forceClassification=true</code> otherwide the model would undergo a <em>regression</em> job.</p><pre><code class="language-julia">myForest       = buildForest(xtrain,ytrain,30, rng=copy(FIXEDRNG),forceClassification=true);</code></pre><p>To obtain the predicted values, we can simply use the function <a href="../../Perceptron.html#BetaML.Api.predict"><code>BetaML.Trees.predict</code></a> with our <code>myForest</code> model and either the training or testing data.</p><pre><code class="language-julia">ŷtrain,ŷtest   = predict.(Ref(myForest), [xtrain,xtest],rng=copy(FIXEDRNG));</code></pre><p>Finally we can measure the <em>accuracy</em> of our predictions with the <a href="../../Utils.html#BetaML.Utils.accuracy-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T"><code>accuracy</code></a> function, with the sidenote that we need first to &quot;parse&quot; the ŷs as forcing the classification job transformed automatically them in strings from the original integers:</p><pre><code class="language-julia">trainAccuracy,testAccuracy  = accuracy.([parse.(Int64,mode(ŷtrain,rng=copy(FIXEDRNG))),parse.(Int64,mode(ŷtest,rng=copy(FIXEDRNG)))],[ytrain,ytest])</code></pre><pre class="documenter-example-output">2-element Vector{Float64}:
 0.9969230769230769
 0.8024691358024691</pre><p>The predictions are quite good, for the training set the algoritm predicted almost all cars&#39; origins correctly, while for the testing set (i.e. those records that has <strong>not</strong> been used to train the algorithm), the correct prediction level is still quite high, at 80%</p><p>While accuracy can sometimes suffice, we may often want to better understand which categories our model has trouble to predict correctly. We can investigate the output of a multi-class classifier more in-deep with a <a href="../../Utils.html#BetaML.Utils.ConfusionMatrix"><code>ConfusionMatrix</code></a> where the true values (<code>y</code>) are given in rows and the predicted ones (<code>ŷ</code>) in columns, together to some per-class metrics like the <em>precision</em> (true class <em>i</em> over predicted in class <em>i</em>), the <em>recall</em> (predicted class <em>i</em> over the true class <em>i</em>) and others. We fist build the <a href="../../Utils.html#BetaML.Utils.ConfusionMatrix"><code>ConfusionMatrix</code></a> object between <code>ŷ</code> and <code>y</code> and then we print it (we do it here for the test subset):</p><pre><code class="language-julia">cm = ConfusionMatrix(parse.(Int64,mode(ŷtest,rng=copy(FIXEDRNG))),ytest,classes=[1,2,3],labels=[&quot;US&quot;,&quot;EU&quot;,&quot;Japan&quot;])
print(cm;what=&quot;all&quot;)</code></pre><pre class="documenter-example-output">
-----------------------------------------------------------------

*** CONFUSION MATRIX ***

Scores actual (rows) vs predicted (columns):


Normalised scores actual (rows) vs predicted (columns):


 *** CONFUSION REPORT ***

- Accuracy:               0.8024691358024691
- Misclassification rate: 0.19753086419753085
- Number of classes:      3

  N Class   precision   recall  specificity  f1Score  actualCount  predictedCount
                          TPR       TNR                 support

  1 US          0.860    0.878        0.781    0.869           49              50
  2 EU          0.722    0.812        0.923    0.765           16              18
  3 Japan       0.692    0.562        0.938    0.621           16              13

- Simple   avg.    0.758    0.751        0.881    0.751
- Weigthed avg.    0.800    0.802        0.840    0.799

-----------------------------------------------------------------</pre><p>From the report we can see that Japanese cars have more trouble in being correctly classified, and in particular many Japanease cars are classified as US ones. This is likely a result of the class imbalance of the data set, and could be solved by balancing the dataset with various sampling tecniques before training the model.</p><p>When we benchmark the resourse used (time and memory) we find that Random Forests remain pretty fast, expecially when we compare them with neural networks (see later)</p><pre><code class="language-julia">@btime buildForest(xtrain,ytrain,30, rng=copy(FIXEDRNG),forceClassification=true);</code></pre><pre class="documenter-example-output">  323.076 ms (780963 allocations: 196.30 MiB)</pre><h3 id="Comparision-with-DecisionTree.jl"><a class="docs-heading-anchor" href="#Comparision-with-DecisionTree.jl">Comparision with DecisionTree.jl</a><a id="Comparision-with-DecisionTree.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Comparision-with-DecisionTree.jl" title="Permalink"></a></h3><p>DecisionTrees.jl random forests are similar in usage: we first &quot;build&quot; (train) the forest and we then make predictions out of the trained model. The main difference is that the model requires data with nonmissing values, so we are going to use the <code>xtrainFull</code> and <code>xtestFull</code> feature labels we created earlier:</p><pre><code class="language-julia"># We train the model...
model = DecisionTree.build_forest(ytrain, xtrainFull,-1,30,rng=123)
# ..and we generate predictions and measure their error
(ŷtrain,ŷtest) = DecisionTree.apply_forest.([model],[xtrainFull,xtestFull]);
(trainAccuracy,testAccuracy) = accuracy.([ŷtrain,ŷtest],[ytrain,ytest])</code></pre><pre class="documenter-example-output">2-element Vector{Float64}:
 0.9969230769230769
 0.7530864197530864</pre><p>While the accuracy on the training set is exactly the same as for <code>BetaML</code> random forets, <code>DecisionTree.jl</code> random forests are slighly less accurate in the testing sample. Where however <code>DecisionTrees.jl</code> excell is in the efficiency: they are extremelly fast and memory parse, even if here to this benchmark we should add the resources need to impute the missing values. Also, one of the reasons DecisionTrees are such efficient is that internally they sort the data to avoid repeated comparision, but in this way they work only with features that are sortable, while BetaML random forests accept virtually any kind of input without the need of adapt it.</p><pre><code class="language-julia">@btime  DecisionTree.build_forest(ytrain, xtrainFull,-1,30,rng=123);</code></pre><pre class="documenter-example-output">  3.275 ms (10875 allocations: 1.52 MiB)</pre><h3 id="Neural-network"><a class="docs-heading-anchor" href="#Neural-network">Neural network</a><a id="Neural-network-1"></a><a class="docs-heading-anchor-permalink" href="#Neural-network" title="Permalink"></a></h3><p>Neural networks (NN) can be very powerfull, but have two &quot;inconvenients&quot; compared with random forests: First, are a bit &quot;picky&quot;. We need to do a bit of work to provide data in specific format. Note that this is <em>not</em> feature engineering. One of the advantages on neural network is that for the most this is not needed for neural networks. However we still need to &quot;clean&quot; the data. One issue is that NN don&#39;t like missing data. So we need to provide them with the feature matrix &quot;clean&quot; of missing data. Secondly, they work only with numerical data. So we need to use the one-hot encoding we saw earlier.</p><pre><code class="language-julia">#Further, they work best if the features are scaled such that each feature has mean zero and standard deviation 1. We can achieve it with the function [`scale`](@ref) or, as in this case, [`getScaleFactors`](@ref).
xScaleFactors   = getScaleFactors(xtrainFull)
D               = size(xtrainFull,2)
classes         = unique(y)
nCl             = length(classes)</code></pre><pre class="documenter-example-output">3</pre><p>The second &quot;inconvenient&quot; of NN is that, while not requiring feature engineering, they stil lneed a bit of practice on the way to build the network. It&#39;s not as simple as <code>train(model,x,y)</code>. We need here to specify how we want our layers, <em>chain</em> the layers together and then decide a <em>loss</em> overall function. Only when we done these steps, we have the model ready for training. Here we define 3 <a href="../../Nn.html#BetaML.Nn.DenseLayer"><code>DenseLayer</code></a> where, for each of them, we specify the number of neurons in input (the first layer being equal to the dimensions of the data), the output layer (for a classification task, the last layer output size beying equal to the number of classes) and an _activation function for each layer (default the <code>identity</code> function).</p><pre><code class="language-julia">ls   = 50
l1   = DenseLayer(D,ls,f=relu,rng=copy(FIXEDRNG))
l2   = DenseLayer(ls,nCl,f=relu,rng=copy(FIXEDRNG))</code></pre><pre class="documenter-example-output">DenseLayer([-0.2146463925907584 -0.3077087587320811 … -0.28256208289474877 0.21510681158042189; -0.08916953797649538 -0.041727530915651345 … -0.30444064706465346 -0.22349634154766507; 0.11376391271810127 -0.011244515923068743 … 0.12916068649773038 -0.2518581440082599], [0.2918467648814228, -0.004167534280141383, 0.29060333096888613], BetaML.Utils.relu, nothing)</pre><p>For a classification the last layer is a <a href="../../Nn.html#BetaML.Nn.VectorFunctionLayer"><code>VectorFunctionLayer</code></a> that has no learnable parameters but whose activation function is applied to the ensemble of the neurons, rather than individually on each neuron. In particular, for classification we pass the <a href="../../Utils.html#BetaML.Utils.softmax-Tuple{Any}"><code>BetaML.Utils.softmax</code></a> function whose output has the same size as the input (and the number of classes to predict), but we can use the <code>VectorFunctionLayer</code> with any function, including the <a href="../../Utils.html#BetaML.Utils.pool1d"><code>pool1d</code></a> function to create a &quot;pooling&quot; layer (using maximum, mean or whatever other subfunction we pass to <code>pool1d</code>)</p><pre><code class="language-julia">l3   = VectorFunctionLayer(nCl,f=softmax) ## Add a (parameterless) layer whose activation function (softMax in this case) is defined to all its nodes at once</code></pre><pre class="documenter-example-output">VectorFunctionLayer(3, 3, BetaML.Utils.softmax, nothing)</pre><p>Finally we <em>chain</em> the layers and assign a loss function</p><pre><code class="language-julia">mynn = buildNetwork([l1,l2,l3],squaredCost,name=&quot;Multinomial logistic regression Model Cars&quot;) ## Build the NN and use the squared cost (aka MSE) as error function (crossEntropy could also be used)</code></pre><pre class="documenter-example-output">NN(AbstractLayer[DenseLayer([-0.20697795942360017 0.12136901733806621 … -0.026906267639792758 -0.08117976159071413; -0.08598387697252577 -0.094763858010351 … 0.12473600153619574 -0.3038923887271602; … ; -0.027245366184114994 -0.13726439265473928 … -0.0812568745415187 0.03639080823771723; 0.21807051339784328 -0.04462192007289573 … -0.09201125674551605 -0.25212961016223523], [-0.32359467997037583, 0.15252213461474667, 0.05681391283261772, -0.0718950523804685, 0.014112894961209654, 0.250715710684788, -0.08912986019414143, -0.22300278678968377, 0.011113501374895696, -0.2307615737177409  …  -0.06868980831928373, 0.22894772322501816, 0.19247052748600918, 0.3243004525232283, -0.005682087946757619, 0.3173647151609262, -0.0419358245557761, 0.1792922925250479, 0.11465680902201164, -0.049714381947920605], BetaML.Utils.relu, nothing), DenseLayer([-0.2146463925907584 -0.3077087587320811 … -0.28256208289474877 0.21510681158042189; -0.08916953797649538 -0.041727530915651345 … -0.30444064706465346 -0.22349634154766507; 0.11376391271810127 -0.011244515923068743 … 0.12916068649773038 -0.2518581440082599], [0.2918467648814228, -0.004167534280141383, 0.29060333096888613], BetaML.Utils.relu, nothing), VectorFunctionLayer(3, 3, BetaML.Utils.softmax, nothing)], BetaML.Utils.squaredCost, nothing, false, &quot;Multinomial logistic regression Model Cars&quot;)</pre><p>Now we can train our network using the function <a href="../../Nn.html#BetaML.Nn.train!-Tuple{NN, Any, Any}"><code>train!</code></a>. It has many options, have a look at the documentation for all the possible arguments. Note that we trained the network based on the scaled feature matrix</p><pre><code class="language-julia">res  = train!(mynn,scale(xtrainFull,xScaleFactors),ytrain_oh,epochs=500,batchSize=8,optAlg=ADAM(),rng=copy(FIXEDRNG)) ## Use optAlg=SGD() to use Stochastic Gradient Descent instead</code></pre><pre class="documenter-example-output">(epochs = 500, ϵ_epochs = [0.3947933466712271, 0.28073284643031027, 0.22540959714717973, 0.2045020231239191, 0.19136110202105647, 0.1829174183357756, 0.17760762488726559, 0.17366196897056083, 0.1706339472451232, 0.16751743542979855  …  0.06798955708038988, 0.06785310875861965, 0.0680514707512953, 0.06843456668489702, 0.06792390250775648, 0.06790615579332532, 0.06768486549836293, 0.06777986689954776, 0.06775912020670322, 0.06776877566449138], θ_epochs = Any[])</pre><p>Once trained, we can predict the label. As the trained was based on the scaled feature matrix, so must be for the predictions</p><pre><code class="language-julia">(ŷtrain,ŷtest)  = predict.(Ref(mynn),[scale(xtrainFull,xScaleFactors),scale(xtestFull,xScaleFactors)])
trainAccuracy   =  accuracy(ŷtrain,ytrain,rng=copy(FIXEDRNG))
testAccuracy    = accuracy(ŷtest,ytest,rng=copy(FIXEDRNG))</code></pre><pre class="documenter-example-output">0.7654320987654321</pre><p>src accuracy(mode(ŷtest,rng=copy(FIXEDRNG)),ytest)</p><pre><code class="language-julia">cm = ConfusionMatrix(ŷtest,ytest,classes=[1,2,3],labels=[&quot;US&quot;,&quot;EU&quot;,&quot;Japan&quot;],rng=copy(FIXEDRNG))
print(cm)</code></pre><pre class="documenter-example-output">
-----------------------------------------------------------------

*** CONFUSION MATRIX ***

Scores actual (rows) vs predicted (columns):


Normalised scores actual (rows) vs predicted (columns):


 *** CONFUSION REPORT ***

- Accuracy:               0.7654320987654321
- Misclassification rate: 0.23456790123456794
- Number of classes:      3

  N Class   precision   recall  specificity  f1Score  actualCount  predictedCount
                          TPR       TNR                 support

  1 US          0.830    0.898        0.719    0.863           49              53
  2 EU          0.833    0.625        0.969    0.714           16              12
  3 Japan       0.500    0.500        0.877    0.500           16              16

- Simple   avg.    0.721    0.674        0.855    0.692
- Weigthed avg.    0.766    0.765        0.799    0.762

-----------------------------------------------------------------</pre><p>We see a bit the limits of neural networks in this example. While NN can be extremelly performant in many domain, they also require lot of data and computational power, expecially considering the many possible hyper-parameters and hence its large space in the hyper-parameter tuning. In this example we arrive short to the performance of random forests, yet with asignificant numberof neurons.</p><pre><code class="language-julia">@btime train!(mynn,scale(xtrainFull),ytrain_oh,epochs=300,batchSize=8,rng=copy(FIXEDRNG),verbosity=NONE);</code></pre><pre class="documenter-example-output">  9.768 s (62860673 allocations: 4.21 GiB)</pre><h3 id="Comparisons-with-Flux"><a class="docs-heading-anchor" href="#Comparisons-with-Flux">Comparisons with Flux</a><a id="Comparisons-with-Flux-1"></a><a class="docs-heading-anchor-permalink" href="#Comparisons-with-Flux" title="Permalink"></a></h3><p>In Flux the input must be in the form (fields, observations), so we transpose our original matrices</p><pre><code class="language-julia">xtrainT, ytrain_ohT = transpose.([scale(xtrainFull,xScaleFactors), ytrain_oh])
xtestT, ytest_ohT   = transpose.([scale(xtestFull,xScaleFactors), ytest_oh])</code></pre><pre class="documenter-example-output">2-element Vector{LinearAlgebra.Transpose{Float64, Matrix{Float64}}}:
 [-0.9354691121867126 0.8211030586728023 … 1.6357452248685191 -0.5790631644760863; 0.3321589709665676 -0.8476406526851753 … -0.2577408408593039 0.3321589709665676; … ; 0.08499289148756756 2.234618551678942 … 1.5539037592850058 -0.022488391522001404; 0.582575265003537 1.1235380110782482 … 1.1235380110782482 -1.3107943462579525]
 [0.0 0.0 … 0.0 1.0; 1.0 1.0 … 1.0 0.0; 0.0 0.0 … 0.0 0.0]</pre><p>We define the Flux neural network model in a similar way than BetaML and load it with data, we train it, predict and measure the accuracies on the training and the test sets:</p><pre><code class="language-julia">Random.seed!(123)

l1         = Flux.Dense(D,ls,Flux.relu)
#l2         = Flux.Dense(ls,ls,Flux.relu)
l3         = Flux.Dense(ls,nCl,Flux.relu)
Flux_nn    = Flux.Chain(l1,l3)
loss(x, y) = Flux.logitcrossentropy(Flux_nn(x), y)
ps         = Flux.params(Flux_nn)
nndata     = Flux.Data.DataLoader((xtrainT, ytrain_ohT), batchsize=8,shuffle=true)
begin for i in 1:500  Flux.train!(loss, ps, nndata, Flux.ADAM()) end end
ŷtrain     = Flux.onecold(Flux_nn(xtrainT),1:3)
ŷtest      = Flux.onecold(Flux_nn(xtestT),1:3)
trainAccuracy =  accuracy(ŷtrain,ytrain)
testAccuracy  = accuracy(ŷtest,ytest)</code></pre><pre class="documenter-example-output">0.7407407407407407</pre><p>While the train accuracy is little bit higher that BetaML, the test accuracy remains comparable</p><p>However the time is again lower than BetaML, even if here for &quot;just&quot; a factor 2</p><pre><code class="language-julia">@btime begin for i in 1:500 Flux.train!(loss, ps, nndata, Flux.ADAM()) end end;</code></pre><pre class="documenter-example-output">  2.350 s (8115000 allocations: 1.03 GiB)</pre><h2 id="Summary"><a class="docs-heading-anchor" href="#Summary">Summary</a><a id="Summary-1"></a><a class="docs-heading-anchor-permalink" href="#Summary" title="Permalink"></a></h2><p>This is the summary of the results we had trying to predict the country of origin of the cars, based on their technical characteristics:</p><table><tr><th style="text-align: left">Model</th><th style="text-align: center">Train acc</th><th style="text-align: right">Test Acc</th><th style="text-align: right">Training time (ms)*</th><th style="text-align: right">Training mem (MB)</th></tr><tr><td style="text-align: left">RF</td><td style="text-align: center">0.9969</td><td style="text-align: right">0.8025</td><td style="text-align: right">134</td><td style="text-align: right">196</td></tr><tr><td style="text-align: left">RF (DecisionTree.jl)</td><td style="text-align: center">0.9969</td><td style="text-align: right">0.7531</td><td style="text-align: right">1.43</td><td style="text-align: right">1.5</td></tr><tr><td style="text-align: left">NN</td><td style="text-align: center">0.895</td><td style="text-align: right">0.765</td><td style="text-align: right">11841</td><td style="text-align: right">4311</td></tr><tr><td style="text-align: left">NN (Flux.jl)</td><td style="text-align: center">0.938</td><td style="text-align: right">0.741</td><td style="text-align: right">5665</td><td style="text-align: right">1096</td></tr></table><ul><li>on a Intel Core i5-8350U laptop</li></ul><p>We warn that this table just provides a rought idea of the various algorithms performances. Indeed there is a large amount of stochasticity both in the sampling of the data used for training/testing and in the initial settings of the parameters of the algorithm. For a statistically significant comparision we would have to repeat the analysis with multiple sampling (e.g. by cross-validation) and initial random parameters. Neverthless the table above shows that, when we compare BetaML with the algorithm-specific leading packages, we found similar results in terms of accuracy, but often the leading packages are better optimised and run more efficiently (but sometimes at the cost of being less verstatile). Also, for this dataset, Random Forests seems to remain marginally more accurate than Neural Network, altought of course this depends on the hyper-parameters and, with a single run of the models, we don&#39;t know if this difference is significant.</p><p><a href="https://github.com/sylvaticus/BetaML.jl/blob/master/docs/src/tutorials/Classification - cars/betaml_tutorial_classification_cars.jl">View this file on Github</a>.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Regression - bike sharing/betaml_tutorial_regression_sharingBikes.html">« A regression task: the prediction of  bike  sharing demand</a><a class="docs-footer-nextpage" href="../Clusterisation - Iris/betaml_tutorial_cluster_iris.html">A classification task: the prediction of  plant species from floreal measures (the iris dataset) »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 18 April 2021 20:36">Sunday 18 April 2021</span>. Using Julia version 1.6.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
