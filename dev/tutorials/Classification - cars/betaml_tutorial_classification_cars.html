<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>A classification task when labels are known - determining the country of origin of cars given the cars characteristics · BetaML.jl Documentation</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">BetaML.jl Documentation</span></div><form class="docs-search" action="../../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../index.html">Index</a></li><li><a class="tocitem" href="../../Perceptron.html">Perceptron</a></li><li><a class="tocitem" href="../../Trees.html">Trees</a></li><li><a class="tocitem" href="../../Nn.html">Nn</a></li><li><a class="tocitem" href="../../Clustering.html">Clustering</a></li><li><a class="tocitem" href="../../Utils.html">Utils</a></li><li><span class="tocitem">Tutorials</span><ul><li><input class="collapse-toggle" id="menuitem-7-1" type="checkbox"/><label class="tocitem" for="menuitem-7-1"><span class="docs-label">Getting started</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../Getting started/betaml_tutorial_getting_started.html">Getting started</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-2" type="checkbox"/><label class="tocitem" for="menuitem-7-2"><span class="docs-label">Regression - bike sharing</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../Regression - bike sharing/betaml_tutorial_regression_sharingBikes.html">A regression task: the prediction of  bike  sharing demand</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-3" type="checkbox" checked/><label class="tocitem" for="menuitem-7-3"><span class="docs-label">Classification - cars</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href="betaml_tutorial_classification_cars.html">A classification task when labels are known - determining the country of origin of cars given the cars characteristics</a><ul class="internal"><li><a class="tocitem" href="#Library-and-data-loading"><span>Library and data loading</span></a></li><li><a class="tocitem" href="#Random-Forests"><span>Random Forests</span></a></li><li><a class="tocitem" href="#Summary"><span>Summary</span></a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-4" type="checkbox"/><label class="tocitem" for="menuitem-7-4"><span class="docs-label">Clusterisation - Iris</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../Clusterisation - Iris/betaml_tutorial_cluster_iris.html">A classification task: the prediction of  plant species from floreal measures (the iris tdataset)</a></li></ul></li></ul></li><li><a class="tocitem" href="../../Examples.html">Examples</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li><a class="is-disabled">Classification - cars</a></li><li class="is-active"><a href="betaml_tutorial_classification_cars.html">A classification task when labels are known - determining the country of origin of cars given the cars characteristics</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="betaml_tutorial_classification_cars.html">A classification task when labels are known - determining the country of origin of cars given the cars characteristics</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/sylvaticus/BetaML.jl/blob/master/docs/src/tutorials/Classification - cars/betaml_tutorial_classification_cars.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="classification_tutorial"><a class="docs-heading-anchor" href="#classification_tutorial">A classification task when labels are known - determining the country of origin of cars given the cars characteristics</a><a id="classification_tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#classification_tutorial" title="Permalink"></a></h1><p>In this exercise we have some car technical characteristics (mpg, horsepower,weight, model year...) and the country of origin and we would like to create a model such that the country of origin can be accurately predicted given the technical characteristics. As the information to predict is a multi-class one, this is a <em>[classification]</em>(https://en.wikipedia.org/wiki/Statistical_classification) task.</p><p>Data origin:</p><ul><li>dataset description: <a href="https://archive.ics.uci.edu/ml/datasets/auto+mpg">https://archive.ics.uci.edu/ml/datasets/auto+mpg</a></li><li>data source we use here: <a href="https://archive.ics.uci.edu/ml/machine-learning-databases/auto-mpg/auto-mpg.data-original">https://archive.ics.uci.edu/ml/machine-learning-databases/auto-mpg/auto-mpg.data</a></li></ul><p>Field description:</p><ol><li>mpg:           <em>continuous</em></li><li>cylinders:     <em>multi-valued discrete</em></li><li>displacement:  <em>continuous</em></li><li>horsepower:    <em>continuous</em></li><li>weight:        <em>continuous</em></li><li>acceleration:  <em>continuous</em></li><li>model year:    <em>multi-valued discrete</em></li><li>origin:        <em>multi-valued discrete</em></li><li>car name:      <em>string (unique for each instance)</em> - not used here</li></ol><h2 id="Library-and-data-loading"><a class="docs-heading-anchor" href="#Library-and-data-loading">Library and data loading</a><a id="Library-and-data-loading-1"></a><a class="docs-heading-anchor-permalink" href="#Library-and-data-loading" title="Permalink"></a></h2><p>We load a buch of packages that we&#39;ll use during this tutorial..</p><pre><code class="language-julia">using Random, HTTP, CSV, DataFrames, BenchmarkTools, BetaML
import DecisionTree, Flux
import Pipe: @pipe</code></pre><p>To load the data from the internet our workflow is (1) Retrieve the data –&gt; (2) Clean it –&gt; (3) Load it –&gt; (4) Output it as a DataFrame.</p><p>For step (1) we use <code>HTTP.get()</code><code>, for step (2) we use</code>replace!<code>, for steps (3) and (4) we uses the</code>CSV<code>package, and we use the &quot;pip&quot;</code>|&gt;` operator to chain these operations:</p><pre><code class="language-">urlDataOriginal = &quot;https://archive.ics.uci.edu/ml/machine-learning-databases/auto-mpg/auto-mpg.data-original&quot;
data = @pipe HTTP.get(urlDataOriginal).body                                                |&gt;
             replace!(_, UInt8(&#39;\t&#39;) =&gt; UInt8(&#39; &#39;))                                        |&gt;
             CSV.File(_, delim=&#39; &#39;, missingstring=&quot;NA&quot;, ignorerepeated=true, header=false) |&gt;
             DataFrame;
nothing #hide</code></pre><p>This results in a table where the rows are the observations (the various cars) and the column the fields. All BetaML models expect this layout. As the dataset is ordered, we randomly shuffle the data. Note that we pass to shuffle <code>copy(FIXEDRNG)</code> as the random nuber generator in order to obtain reproducible output ( <a href="../../Utils.html#BetaML.Utils.FIXEDRNG"><code>FIXEDRNG</code></a> is nothing else than an istance of <code>StableRNG(123)</code> defined in the <a href="../../Utils.html#BetaML.Utils"><code>BetaML.Utils</code></a> sub-module, but you can choose of course your own &quot;fixed&quot; RNG). See the <a href="../Getting started/betaml_tutorial_getting_started.html#dealing_with_stochasticity">Dealing with stochasticity</a> section in the <a href="../Getting started/betaml_tutorial_getting_started.html#Getting-started">Getting started</a> tutorial for details.</p><pre><code class="language-">data[shuffle(copy(FIXEDRNG),axes(data, 1)), :]
describe(data)</code></pre><p>Columns 1 to 7 contain  characteristics of the car, while column 8 encodes the country or origin (&quot;1&quot; -&gt; US, &quot;2&quot; -&gt; EU, &quot;3&quot; -&gt; Japan). That&#39;s what we want to be able to predict. Columns 9 contains the car name, but we are not going to use this information in this tutorial. Note also that some fields have missing data. Our first step is hence to divide the dataset in features (the x) and the labels (the y) we want to predict. The <code>x</code> is then a Julia standard <code>Matrix</code> of 406 rows by 7 columns and the <code>y</code> is a vector of the 406 observations:</p><pre><code class="language-">x     = Matrix{Union{Missing,Float64}}(data[:,1:7]);
y     = Vector{Int64}(data[:,8]);
nothing #hide</code></pre><p>Some algorithms that we will use today don&#39;t like missing data, so we need to <em>impute</em> them. Foir this we are using the <a href="../../Clustering.html#BetaML.Clustering.predictMissing"><code>predictMissing</code></a> function provided by the <a href="../../Clustering.html#BetaML.Clustering"><code>BetaML.Clustering</code></a> sub-module. Internally the function uses a Gaussian Mixture Model to assign to the missing walue of a given record an average of the values of the non-missing records weighted for how close they are to our specific record.</p><pre><code class="language-">xFull = predictMissing(x,rng=copy(FIXEDRNG)).X̂;
nothing #hide</code></pre><p>Further, some models don&#39;t work with categorical data as such, so we need to represent our <code>y</code> as a matrix with a separate column for each possible categorical value (the so called &quot;one-hot&quot; representation). For example, within a three classes field, the individual value <code>2</code> (or <code>&quot;Europe&quot;</code> for what it matters) would be represented as the vector <code>[0 1 0]</code>, while <code>3</code> (or <code>&quot;Japan&quot;</code>) wpuld become the vector <code>[0 0 1]</code>. To encode as one-hot we use the function <a href="../../Utils.html#BetaML.Utils.oneHotEncoder-Union{Tuple{Union{AbstractVector{T}, T}}, Tuple{T}} where T"><code>oneHotEncoder</code></a> in <a href="../../Utils.html#BetaML.Utils"><code>BetaML.Utils</code></a></p><pre><code class="language-">y_oh  = oneHotEncoder(y);
nothing #hide</code></pre><p>In supervised machine learning it is good practice to partition the available data in a <em>training</em>, <em>validation</em>, and <em>test</em> subsets, where the first one is used to train the ML algorithm, the second one to train any eventual &quot;hyper-parameters&quot; of the algorithm and the <em>test</em> subset is finally used to evaluate the quality of the algorithm. Here, for brevity, we use only the <em>train</em> and the <em>test</em> subsets, implicitly assuming we already know the best hyper-parameters. Please refer to the <a href="../Regression - bike sharing/betaml_tutorial_regression_sharingBikes.html#regression_tutorial">regression tutorial</a> for examples of how to use the validation subset to train the hyper-parameters. We use then the <code>partition</code> function in <a href="tutorials/Classification - cars/@ref">BetaML.Utils</a>, where we can specify the different data to partition (that must have the same number of observations) and the shares of observation that we want in each subset.</p><pre><code class="language-">((xtrain,xtest),(xtrainFull,xtestFull),(ytrain,ytest),(ytrain_oh,ytest_oh)) = partition([x,xFull,y,y_oh],[0.8,1-0.8],rng=copy(FIXEDRNG));
nothing #hide</code></pre><h2 id="Random-Forests"><a class="docs-heading-anchor" href="#Random-Forests">Random Forests</a><a id="Random-Forests-1"></a><a class="docs-heading-anchor-permalink" href="#Random-Forests" title="Permalink"></a></h2><p>We are now ready to use our first model, the Random Forests (in the <a href="../../Trees.html#BetaML.Trees"><code>BetaML.Trees</code></a> sub-module). Random Forests build a &quot;forest&quot; of decision trees models and then average their predictions to make an overall prediction out of a feature vector. To &quot;build&quot; the forest model (i.e. to &quot;train&quot; it) we need to give the model the training feature matrix and the associated &quot;true&quot; training labels, and we need to specify the number of trees to employ (this is an example of hyper-parameters). Here we use 30 individual decision trees. As the labels are encoded using integers,  we need also to use the parameter <code>forceClassification=true</code> otherwide the model would undergo a <em>regression</em> job.</p><pre><code class="language-">myForest       = buildForest(xtrain,ytrain,30, rng=copy(FIXEDRNG),forceClassification=true);
nothing #hide</code></pre><p>To obtain the predicted values, we can simply use the function <a href="../../Perceptron.html#BetaML.Api.predict"><code>BetaML.Trees.predict</code></a> with our <code>myForest</code> model and either the training or testing data.</p><pre><code class="language-">ŷtrain,ŷtest   = predict.(Ref(myForest), [xtrain,xtest],rng=copy(FIXEDRNG));
nothing #hide</code></pre><p>Finally we can measure the <em>accuracy</em> of our predictions with the <a href="../../Utils.html#BetaML.Utils.accuracy-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T"><code>accuracy</code></a> function:</p><pre><code class="language-">trainAccuracy,testAccuracy  = accuracy.([parse.(Int64,mode(ŷtrain)),parse.(Int64,mode(ŷtest))],[ytrain,ytest])</code></pre><p>The predictions are quite good, for the training set the algoritm predicted almost all cars&#39; origins correctly, while for the testing set (i.e. those records that has <strong>not</strong> been used to train the algorithm), the correct prediction level is still quite high, at 80% When we benchmark the resourse used (time and memory) we find that Random Forests remain pretty fast, expecially when we compare them with neural networks (see later)</p><pre><code class="language-">@btime buildForest(xtrain,ytrain,30, rng=copy(FIXEDRNG),forceClassification=true);
nothing #hide</code></pre><h3 id="Comparision-with-DecisionTree.jl"><a class="docs-heading-anchor" href="#Comparision-with-DecisionTree.jl">Comparision with DecisionTree.jl</a><a id="Comparision-with-DecisionTree.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Comparision-with-DecisionTree.jl" title="Permalink"></a></h3><p>DecisionTrees.jl random forests are similar in usage: we first &quot;build&quot; (train) the forest and we then make predictions out of the trained model. The main difference is that the model requires data with nonmissing values, so we are going to use the <code>xtrainFull</code> and <code>xtestFull</code> feature labels we created earlier:</p><pre><code class="language-"># We train the model...
model = DecisionTree.build_forest(ytrain, xtrainFull,-1,30,rng=123)
# ..and we generate predictions and measure their error
(ŷtrain,ŷtest) = DecisionTree.apply_forest.([model],[xtrainFull,xtestFull]);
(trainAccuracy,testAccuracy) = accuracy.([ŷtrain,ŷtest],[ytrain,ytest])</code></pre><p>While the accuracy on the training set is exactly the same as for <code>BetaML</code> random forets, <code>DecisionTree.jl</code> random forests are slighly less accurate in the testing sample. Where however <code>DecisionTrees.jl</code> excell is in the efficiency: they are extremelly fast and memory parse, even if here to this benchmark we should add the resources need to impute the missing values. Also, one of the reasons DecisionTrees are such efficient is that internally they sort the data to avoid repeated comparision, but in this way they work only with features that are sortable, while BetaML random forests accept virtually any kind of input without the need of adapt it.</p><pre><code class="language-">@btime  DecisionTree.build_forest(ytrain, xtrainFull,-1,30,rng=123);
nothing #hide</code></pre><h3 id="Neural-network"><a class="docs-heading-anchor" href="#Neural-network">Neural network</a><a id="Neural-network-1"></a><a class="docs-heading-anchor-permalink" href="#Neural-network" title="Permalink"></a></h3><p>Neural networks (NN) can be very powerfull, but have two &quot;inconvenients&quot; compared with random forests: First, are a bit &quot;picky&quot;. We need to do a bit of work to provide data in specific format. Note that this is <em>not</em> feature engineering. One of the advantages on neural network is that for the most this is not needed for neural networks. However we still need to &quot;clean&quot; the data. One issue is that NN don&#39;t like missing data. So we need to provide them with the feature matrix &quot;clean&quot; of missing data. Secondly, they work only with numerical data. So we need to use the one-hot encoding we saw earlier.</p><pre><code class="language-">#Further, they work best if the features are scaled such that each feature has mean zero and standard deviation 1. We can achieve it with the function [`scale`](@ref) or, as in this case, [`getScaleFactors`](@ref).
xScaleFactors   = getScaleFactors(xtrainFull)
D               = size(xtrainFull,2)
classes         = unique(y)
nCl             = length(classes)</code></pre><p>The second &quot;inconvenient&quot; of NN i that, while not requiring feature engineering, they stil lneed a bit of practice on the way to build the network. It&#39;s not as simple as <code>train(model,x,y)</code>. We need here to specify how we want our layers, <em>chain</em> the layers together and then decide a <em>loss</em> overall function. Only when we done these steps, we have the model ready for training. Here we define 3 <a href="../../Nn.html#BetaML.Nn.DenseLayer"><code>DenseLayer</code></a> zwhere, for each of them, we specify the number of neurons in input (the first layer being equal to the dimensions of the data), the output layer (for a classification task, the last layer output size beying equal to the number of classes) and an _activation function for each layer (default the <code>identity</code> function).</p><pre><code class="language-">ls   = 80
l1   = DenseLayer(D,ls,f=relu,rng=copy(FIXEDRNG)) ## Activation function is ReLU
l2   = DenseLayer(ls,ls,f=relu,rng=copy(FIXEDRNG))
l3   = DenseLayer(ls,nCl,f=relu,rng=copy(FIXEDRNG))</code></pre><p>For a classification the last layer is a <a href="../../Nn.html#BetaML.Nn.VectorFunctionLayer"><code>VectorFunctionLayer</code></a> that has no learnable parameters but whose activation function is applied to the ensemble of the neurons, rather than individually on each neuron. In particular, for classification we pass the <a href="../../Utils.html#BetaML.Utils.softmax-Tuple{Any}"><code>BetaML.Utils.softmax</code></a> function whose output has the same size as the input (and the number of classes to predict), but we can use the <code>VectorFunctionLayer</code> with any function, including the <a href="../../Utils.html#BetaML.Utils.pool1d"><code>pool1d</code></a> function to create a &quot;pooling&quot; layer (using maximum, mean or whatever other subfunction we pass to <code>pool1d</code>)</p><pre><code class="language-">l4   = VectorFunctionLayer(nCl,f=softmax) ## Add a (parameterless) layer whose activation function (softMax in this case) is defined to all its nodes at once</code></pre><p>Finally we <em>chain</em> the layers and assign a loss function</p><pre><code class="language-">mynn = buildNetwork([l1,l2,l3],squaredCost,name=&quot;Multinomial logistic regression Model Cars&quot;) ## Build the NN and use the squared cost (aka MSE) as error function (crossEntropy could also be used)</code></pre><p>Now we can train our network using the function <a href="../../Nn.html#BetaML.Nn.train!-Tuple{NN, Any, Any}"><code>train!</code></a>. It has many options, have a look at the documentation for all the possible arguments. Note that we trained the network based on the scaled feature matrix</p><pre><code class="language-">res = train!(mynn,scale(xtrainFull,xScaleFactors),ytrain_oh,epochs=300,batchSize=16,rng=copy(FIXEDRNG)) ## Use optAlg=SGD() to use Stochastic Gradient Descent instead</code></pre><p>Once trained, we can predict the label. As the trained was based on the scaled feature matrix, so must be for the predictions</p><pre><code class="language-">(ŷtrain,ŷtest)  = predict.(Ref(mynn),[scale(xtrainFull,xScaleFactors),scale(xtestFull,xScaleFactors)])
(trainAccuracy,testAccuracy) = accuracy.([ŷtrain,ŷtest],[ytrain,ytest])</code></pre><p>With neural networks the tesst accuracy improves of 7 percentual points. However this come with a large computational cost, at the training takes now several seconds:</p><pre><code class="language-">@btime train!(mynn,scale(xtrainFull),ytrain_oh,epochs=300,batchSize=8,rng=copy(FIXEDRNG),verbosity=NONE);
nothing #hide</code></pre><h3 id="Comparisons-with-Flux"><a class="docs-heading-anchor" href="#Comparisons-with-Flux">Comparisons with Flux</a><a id="Comparisons-with-Flux-1"></a><a class="docs-heading-anchor-permalink" href="#Comparisons-with-Flux" title="Permalink"></a></h3><p>In Flux the input bust be in the form (fields, observations), so we transpose our original matrices</p><pre><code class="language-">xtrainT, ytrain_ohT = transpose.([scale(xtrainFull,xScaleFactors), ytrain_oh])
xtestT, ytest_ohT = transpose.([scale(xtestFull,xScaleFactors), ytest_oh])</code></pre><p>We define the Flux neural network model in a similar way than BetaML and load it with data, we train it, predict and measure the accuracies on the training and the test sets:</p><pre><code class="language-">Random.seed!(123)

l1         = Flux.Dense(D,ls,Flux.relu)
l2         = Flux.Dense(ls,ls,Flux.relu)
l3         = Flux.Dense(ls,nCl,Flux.relu)
Flux_nn    = Flux.Chain(l1,l2,l3)
loss(x, y) = Flux.logitcrossentropy(Flux_nn(x), y)
ps         = Flux.params(Flux_nn)
nndata     = Flux.Data.DataLoader((xtrainT, ytrain_ohT), batchsize=16,shuffle=true)
begin for i in 1:300  Flux.train!(loss, ps, nndata, Flux.ADAM()) end end
ŷtrain     = Flux.onecold(Flux_nn(xtrainT),1:3)
ŷtest      = Flux.onecold(Flux_nn(xtestT),1:3)
(trainAccuracy,testAccuracy) = accuracy.([ŷtrain,ŷtest],[ytrain,ytest])</code></pre><p>While the train accuracy is the same as in BetaML, the test accuracy is somehow lower</p><p>However the time is again lower than BetaML, even if here for &quot;just&quot; a factor 2</p><pre><code class="language-">@btime begin for i in 1:300 Flux.train!(loss, ps, nndata, Flux.ADAM()) end end;
nothing #hide</code></pre><h2 id="Summary"><a class="docs-heading-anchor" href="#Summary">Summary</a><a id="Summary-1"></a><a class="docs-heading-anchor-permalink" href="#Summary" title="Permalink"></a></h2><p>This is the summary of the results we had trying to predict the country of origin of the cars, based on their technical characteristics:</p><table><tr><th style="text-align: left">Model</th><th style="text-align: center">Train acc</th><th style="text-align: right">Test Acc</th><th style="text-align: right">Training time (ms)*</th><th style="text-align: right">Training mem (MB)</th></tr><tr><td style="text-align: left">RF</td><td style="text-align: center">0.9969</td><td style="text-align: right">0.8025</td><td style="text-align: right">133</td><td style="text-align: right">196</td></tr><tr><td style="text-align: left">RF (DecisionTree.jl)</td><td style="text-align: center">0.9969</td><td style="text-align: right">0.7531</td><td style="text-align: right">1.4</td><td style="text-align: right">1.5</td></tr><tr><td style="text-align: left">NN</td><td style="text-align: center">0.9754</td><td style="text-align: right">0.8765</td><td style="text-align: right">10684</td><td style="text-align: right">22241</td></tr><tr><td style="text-align: left">NN (Flux.jl)</td><td style="text-align: center">0.9692</td><td style="text-align: right">0.7284</td><td style="text-align: right">9164</td><td style="text-align: right">1577</td></tr></table><ul><li>on a Intel Core i5-8350U laptop</li></ul><p>We find a similar situation as in the bike&#39;s demand <a href="tutorials/Classification - cars/@ref">regression tutorial</a>: neural networks can be more precise than random forests models, but are more computationally expensive (and tricky to set up). When we compare BetaML with the algorithm-specific leading packages, we found similar results in terms of accuracy, but often the leading packages are better optimised and run more efficiently (but sometimes at the cost of being less verstatile).</p><p><a href="https://github.com/sylvaticus/BetaML.jl/blob/master/docs/src/tutorials/Classification - cars/betaml_tutorial_classification_cars.jl">View this file on Github</a>.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Regression - bike sharing/betaml_tutorial_regression_sharingBikes.html">« A regression task: the prediction of  bike  sharing demand</a><a class="docs-footer-nextpage" href="../Clusterisation - Iris/betaml_tutorial_cluster_iris.html">A classification task: the prediction of  plant species from floreal measures (the iris tdataset) »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 5 April 2021 22:07">Monday 5 April 2021</span>. Using Julia version 1.6.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
